// This file is auto-generated by @hey-api/openapi-ts

export type ApiKeyReadable = {
  readonly prefix: string;
  readonly created: string;
  readonly creator: string | null;
  /**
   * A free-form name for the API key. Need not be unique. 50 characters max.
   */
  readonly name: string;
  /**
   * Once API key expires, clients cannot use it anymore.
   */
  readonly expiryDate: string | null;
  /**
   * If the API key is revoked, clients cannot use it anymore. (This cannot be undone.)
   */
  revoked?: boolean;
};

export type ApiKeyWritable = {
  /**
   * If the API key is revoked, clients cannot use it anymore. (This cannot be undone.)
   */
  revoked?: boolean;
};

export type ApiKeyCreateReadable = {
  readonly prefix: string;
  readonly created: string;
  readonly creator: string | null;
  /**
   * The API key itself. Will be generated on creation but not returned in future requests.
   */
  readonly secret: string;
  /**
   * If the API key is revoked, clients cannot use it anymore. (This cannot be undone.)
   */
  readonly revoked: boolean;
  /**
   * A free-form name for the API key. Need not be unique. 50 characters max.
   */
  name: string;
  /**
   * Once API key expires, clients cannot use it anymore.
   */
  expiryDate?: string | null;
};

export type ApiKeyCreateWritable = {
  /**
   * A free-form name for the API key. Need not be unique. 50 characters max.
   */
  name: string;
  /**
   * Once API key expires, clients cannot use it anymore.
   */
  expiryDate?: string | null;
};

export type AccountReadable = {
  readonly name: string;
  readonly billingUrl: string;
  /**
   * How much free time has been used by previous (or ongoing) calls.
   */
  readonly freeTimeUsed: string;
  /**
   * How much free call time this account has remaining. (This could increase if an existing call ends without using its maximum duration or an unjoined call times out.)
   */
  readonly freeTimeRemaining: string;
  /**
   * Whether the account has an active subscription.
   */
  hasActiveSubscription: boolean;
  /**
   * The current subscription tier for this account.
   */
  readonly subscriptionTier: string | null;
  /**
   * How often the subscription is billed for this account.
   */
  readonly subscriptionCadence: string | null;
  /**
   * The expiration date of the current subscription for this account, if any. This is the point at which access will end unless credit remains.
   */
  readonly subscriptionExpiration: string | null;
  /**
   * The point in the future where this account's subscription is scheduled to change.
   */
  readonly subscriptionScheduledUpdate: string | null;
  /**
   * The number of active calls for this account.
   */
  readonly activeCalls: number;
  /**
   * The maximum number of concurrent calls allowed for this account.
   */
  readonly allowedConcurrentCalls: number | null;
  /**
   * The maximum number of custom voices allowed for this account.
   */
  readonly allowedVoices: number | null;
  /**
   * The maximum number of corpora allowed for this account.
   */
  readonly allowedCorpora: number | null;
};

export type AccountWritable = {
  /**
   * Whether the account has an active subscription.
   */
  hasActiveSubscription: boolean;
};

export type AccountBillingInfo = {
  /**
   * Obfuscated current payment method.
   */
  readonly paymentMethod: string | null;
  /**
   * Email address for billing notifications.
   */
  readonly billingEmail: string | null;
};

export type AccountTtsKeys = {
  /**
   * The ElevenLabs API key.
   */
  elevenLabs?: KeyPrefix;
  /**
   * The Cartesia API key.
   */
  cartesia?: KeyPrefix;
  /**
   * The PlayHT API key.
   */
  playHt?: KeyPrefix;
  /**
   * The LMNT API key.
   */
  lmnt?: KeyPrefix;
};

export type AgentReadable = {
  readonly agentId: string;
  name?: string;
  readonly created: string;
  callTemplate?: UltravoxV1CallTemplate | null;
  /**
   * Statistics about the agent's usage
   */
  readonly statistics: {
    calls?: number;
  };
};

export type AgentWritable = {
  name?: string;
  callTemplate?: UltravoxV1CallTemplate | null;
};

/**
 * * `manual` - manual
 * * `subscription_create` - subscription_create
 * * `subscription_cycle` - subscription_cycle
 * * `subscription_threshold` - subscription_threshold
 * * `subscription_update` - subscription_update
 */
export type BillingReasonEnum =
  | 'manual'
  | 'subscription_create'
  | 'subscription_cycle'
  | 'subscription_threshold'
  | 'subscription_update';

export type BillingUsageDay = {
  /**
   * The date (UTC) of the usage.
   */
  date: string;
  /**
   * Total minutes billed on this date.
   */
  minutes: number;
};

export type CallReadable = {
  readonly callId: string;
  /**
   * The version of the client that joined this call.
   */
  readonly clientVersion: string | null;
  readonly created: string;
  readonly joined: string | null;
  readonly ended: string | null;
  /**
   * The reason the call ended.
   *
   * * `unjoined` - Client never joined
   * * `hangup` - Client hung up
   * * `agent_hangup` - Agent hung up
   * * `timeout` - Call timed out
   * * `connection_error` - Connection error
   * * `system_error` - System error
   */
  endReason: EndReasonEnum | NullEnum | null;
  /**
   * Who was supposed to talk first when the call started. Typically set to FIRST_SPEAKER_USER for outgoing calls and left as the default (FIRST_SPEAKER_AGENT) otherwise.
   * @deprecated
   */
  firstSpeaker: FirstSpeakerEnum;
  /**
   * Settings for the initial message to get the call started.
   */
  firstSpeakerSettings: UltravoxV1FirstSpeakerSettings;
  /**
   * Messages spoken by the agent when the user is inactive for the specified duration. Durations are cumulative, so a message m > 1 with duration 30s will be spoken 30 seconds after message m-1.
   */
  inactivityMessages?: Array<UltravoxV1TimedMessage>;
  /**
   * The medium used initially by the agent. May later be changed by the client.
   */
  initialOutputMedium: InitialOutputMediumEnum;
  joinTimeout?: string;
  readonly joinUrl: string | null;
  /**
   * BCP47 language code that may be used to guide speech recognition.
   */
  languageHint?: string | null;
  maxDuration?: string;
  medium?: UltravoxV1CallMedium | null;
  model?: string;
  recordingEnabled?: boolean;
  systemPrompt?: string | null;
  temperature?: number;
  timeExceededMessage?: string | null;
  voice?: string | null;
  externalVoice?: UltravoxV1ExternalVoice;
  /**
   * Indicates whether a transcript is optional for the call.
   * @deprecated
   */
  transcriptOptional?: boolean;
  /**
   * The number of errors in this call.
   */
  readonly errorCount: number;
  /**
   * VAD settings for the call.
   */
  vadSettings?: UltravoxV1VadSettings | null;
  /**
   * A short summary of the call.
   */
  readonly shortSummary: string | null;
  /**
   * A summary of the call.
   */
  readonly summary: string | null;
  /**
   * Experimental settings for the call.
   */
  experimentalSettings: unknown;
  /**
   * Optional metadata key-value pairs to associate with the call. All values must be strings.
   */
  metadata: {
    [key: string]: string;
  };
  /**
   * The initial state of the call which is readable/writable by tools.
   */
  initialState: {
    [key: string]: unknown;
  };
  requestContext: unknown;
  /**
   * Settings for exchanging data messages with an additional participant.
   */
  dataConnectionConfig?: UltravoxV1DataConnectionConfig;
};

export type CallWritable = {
  /**
   * The reason the call ended.
   *
   * * `unjoined` - Client never joined
   * * `hangup` - Client hung up
   * * `agent_hangup` - Agent hung up
   * * `timeout` - Call timed out
   * * `connection_error` - Connection error
   * * `system_error` - System error
   */
  endReason: EndReasonEnum | NullEnum | null;
  /**
   * Who was supposed to talk first when the call started. Typically set to FIRST_SPEAKER_USER for outgoing calls and left as the default (FIRST_SPEAKER_AGENT) otherwise.
   * @deprecated
   */
  firstSpeaker: FirstSpeakerEnum;
  /**
   * Settings for the initial message to get the call started.
   */
  firstSpeakerSettings: UltravoxV1FirstSpeakerSettings;
  /**
   * Messages spoken by the agent when the user is inactive for the specified duration. Durations are cumulative, so a message m > 1 with duration 30s will be spoken 30 seconds after message m-1.
   */
  inactivityMessages?: Array<UltravoxV1TimedMessage>;
  /**
   * The medium used initially by the agent. May later be changed by the client.
   */
  initialOutputMedium: InitialOutputMediumEnum;
  joinTimeout?: string;
  /**
   * BCP47 language code that may be used to guide speech recognition.
   */
  languageHint?: string | null;
  maxDuration?: string;
  medium?: UltravoxV1CallMedium | null;
  model?: string;
  recordingEnabled?: boolean;
  systemPrompt?: string | null;
  temperature?: number;
  timeExceededMessage?: string | null;
  voice?: string | null;
  externalVoice?: UltravoxV1ExternalVoice;
  /**
   * Indicates whether a transcript is optional for the call.
   * @deprecated
   */
  transcriptOptional?: boolean;
  /**
   * VAD settings for the call.
   */
  vadSettings?: UltravoxV1VadSettings | null;
  /**
   * Experimental settings for the call.
   */
  experimentalSettings: unknown;
  /**
   * Optional metadata key-value pairs to associate with the call. All values must be strings.
   */
  metadata: {
    [key: string]: string;
  };
  /**
   * The initial state of the call which is readable/writable by tools.
   */
  initialState: {
    [key: string]: unknown;
  };
  requestContext: unknown;
  /**
   * Settings for exchanging data messages with an additional participant.
   */
  dataConnectionConfig?: UltravoxV1DataConnectionConfig;
};

export type CallStageReadable = {
  readonly callId: string;
  readonly callStageId: string;
  readonly created: string;
  /**
   * Messages spoken by the agent when the user is inactive for the specified duration. Durations are cumulative, so a message m > 1 with duration 30s will be spoken 30 seconds after message m-1.
   */
  inactivityMessages?: Array<UltravoxV1TimedMessage>;
  /**
   * BCP47 language code that may be used to guide speech recognition.
   */
  languageHint?: string | null;
  model?: string;
  systemPrompt?: string | null;
  readonly temperature: number;
  timeExceededMessage?: string | null;
  voice?: string | null;
  externalVoice?: UltravoxV1ExternalVoice;
  /**
   * The number of errors in this call stage.
   */
  readonly errorCount: number;
  /**
   * Experimental settings for this call stage.
   */
  readonly experimentalSettings: unknown;
  /**
   * The initial state of the call stage which is readable/writable by tools.
   */
  initialState: {
    [key: string]: unknown;
  };
};

export type CallStageWritable = {
  /**
   * Messages spoken by the agent when the user is inactive for the specified duration. Durations are cumulative, so a message m > 1 with duration 30s will be spoken 30 seconds after message m-1.
   */
  inactivityMessages?: Array<UltravoxV1TimedMessage>;
  /**
   * BCP47 language code that may be used to guide speech recognition.
   */
  languageHint?: string | null;
  model?: string;
  systemPrompt?: string | null;
  timeExceededMessage?: string | null;
  voice?: string | null;
  externalVoice?: UltravoxV1ExternalVoice;
  /**
   * The initial state of the call stage which is readable/writable by tools.
   */
  initialState: {
    [key: string]: unknown;
  };
};

export type CallStatistics = {
  /**
   * Total number of calls
   */
  totalCount: number;
  /**
   * Total duration of all calls
   */
  duration: string;
  /**
   * Number of calls that were joined
   */
  joinedCount: number;
};

export type CallTombstoneReadable = {
  readonly callId: string;
  readonly accountId: string;
  created: string;
  readonly deletionTime: string;
  joined?: string | null;
  ended?: string | null;
  maxDuration?: string;
  /**
   * The reason the call ended.
   *
   * * `unjoined` - Client never joined
   * * `hangup` - Client hung up
   * * `agent_hangup` - Agent hung up
   * * `timeout` - Call timed out
   * * `connection_error` - Connection error
   * * `system_error` - System error
   */
  endReason: EndReasonEnum | NullEnum | null;
  readonly recordingEnabled: boolean;
  readonly hadSummary: boolean;
};

export type CallTombstoneWritable = {
  created: string;
  joined?: string | null;
  ended?: string | null;
  maxDuration?: string;
  /**
   * The reason the call ended.
   *
   * * `unjoined` - Client never joined
   * * `hangup` - Client hung up
   * * `agent_hangup` - Agent hung up
   * * `timeout` - Call timed out
   * * `connection_error` - Connection error
   * * `system_error` - System error
   */
  endReason: EndReasonEnum | NullEnum | null;
};

export type CallToolReadable = {
  readonly callToolId: string;
  readonly toolId: string | null;
  /**
   * The possibly overridden name of the tool.
   */
  readonly name: string;
  definition: UltravoxV1CallTool;
};

export type CallToolWritable = {
  definition: UltravoxV1CallTool;
};

export type CallUsage = {
  /**
   * All-time call usage
   */
  allTime: CallStatistics;
  /**
   * Call usage per day
   */
  daily: Array<DailyCallStatistics>;
};

export type CorpusUploadsRequest = {
  /**
   * The MIME type of the file to be uploaded.
   */
  mimeType: string;
  /**
   * The name of the file to be uploaded.
   */
  fileName?: string;
};

export type CorpusUploadsResponse = {
  documentId: string;
  presignedUrl: string;
};

export type DailyCallStatistics = {
  /**
   * Total number of calls
   */
  totalCount: number;
  /**
   * Total duration of all calls
   */
  duration: string;
  /**
   * Number of calls that were joined
   */
  joinedCount: number;
  /**
   * Date of usage
   */
  date: string;
};

/**
 * * `unjoined` - Client never joined
 * * `hangup` - Client hung up
 * * `agent_hangup` - Agent hung up
 * * `timeout` - Call timed out
 * * `connection_error` - Connection error
 * * `system_error` - System error
 */
export type EndReasonEnum =
  | 'unjoined'
  | 'hangup'
  | 'agent_hangup'
  | 'timeout'
  | 'connection_error'
  | 'system_error';

/**
 * * `call.started` - Fired when a call starts
 * * `call.joined` - Fired when a call is joined
 * * `call.ended` - Fired when a call ends
 */
export type EventsEnum = 'call.started' | 'call.joined' | 'call.ended';

export type FirstSpeakerEnum = 'FIRST_SPEAKER_AGENT' | 'FIRST_SPEAKER_USER';

export type InitialOutputMediumEnum =
  | 'MESSAGE_MEDIUM_VOICE'
  | 'MESSAGE_MEDIUM_TEXT';

export type InvoiceReadable = {
  /**
   * When the invoice became effective.
   */
  readonly invoiceDate: string;
  readonly amount: number;
  billingReason: BillingReasonEnum;
  readonly invoiceNumber: string;
  invoiceStatus: InvoiceStatusEnum;
  invoiceUrl: string;
};

export type InvoiceWritable = {
  billingReason: BillingReasonEnum;
  invoiceStatus: InvoiceStatusEnum;
  invoiceUrl: string;
};

/**
 * * `paid` - paid
 * * `unpaid` - unpaid
 */
export type InvoiceStatusEnum = 'paid' | 'unpaid';

export type KeyPrefix = {
  /**
   * The prefix of the API key.
   */
  prefix: string;
};

export type ModelAlias = {
  /**
   * The alias name.
   */
  readonly name: string;
};

export type NullEnum = unknown;

export type OwnershipEnum = 'public' | 'private';

export type PaginatedApiKeyListReadable = {
  next?: string | null;
  previous?: string | null;
  results: Array<ApiKeyReadable>;
  total?: number;
};

export type PaginatedApiKeyListWritable = {
  next?: string | null;
  previous?: string | null;
  results: Array<ApiKeyWritable>;
  total?: number;
};

export type PaginatedAgentListReadable = {
  next?: string | null;
  previous?: string | null;
  results: Array<AgentReadable>;
  total?: number;
};

export type PaginatedAgentListWritable = {
  next?: string | null;
  previous?: string | null;
  results: Array<AgentWritable>;
  total?: number;
};

export type PaginatedCallListReadable = {
  next?: string | null;
  previous?: string | null;
  results: Array<CallReadable>;
  total?: number;
};

export type PaginatedCallListWritable = {
  next?: string | null;
  previous?: string | null;
  results: Array<CallWritable>;
  total?: number;
};

export type PaginatedCallStageListReadable = {
  next?: string | null;
  previous?: string | null;
  results: Array<CallStageReadable>;
  total?: number;
};

export type PaginatedCallStageListWritable = {
  next?: string | null;
  previous?: string | null;
  results: Array<CallStageWritable>;
  total?: number;
};

export type PaginatedCallTombstoneListReadable = {
  next?: string | null;
  previous?: string | null;
  results: Array<CallTombstoneReadable>;
  total?: number;
};

export type PaginatedCallTombstoneListWritable = {
  next?: string | null;
  previous?: string | null;
  results: Array<CallTombstoneWritable>;
  total?: number;
};

export type PaginatedInvoiceListReadable = {
  results: Array<InvoiceReadable>;
  readonly next: string | null;
  readonly previous: string | null;
};

export type PaginatedInvoiceListWritable = {
  results: Array<InvoiceWritable>;
};

export type PaginatedModelAliasListReadable = {
  next?: string | null;
  previous?: string | null;
  results: Array<ModelAlias>;
  total?: number;
};

export type PaginatedModelAliasListWritable = {
  next?: string | null;
  previous?: string | null;
  results: Array<ModelAlias>;
  total?: number;
};

export type PaginatedToolHistoryListReadable = {
  next?: string | null;
  previous?: string | null;
  results: Array<ToolHistoryReadable>;
  total?: number;
};

export type PaginatedToolHistoryListWritable = {
  next?: string | null;
  previous?: string | null;
  results: Array<ToolHistoryWritable>;
  total?: number;
};

export type PaginatedToolListReadable = {
  next?: string | null;
  previous?: string | null;
  results: Array<ToolReadable>;
  total?: number;
};

export type PaginatedToolListWritable = {
  next?: string | null;
  previous?: string | null;
  results: Array<ToolWritable>;
  total?: number;
};

export type PaginatedVoiceListReadable = {
  next?: string | null;
  previous?: string | null;
  results: Array<Voice>;
  total?: number;
};

export type PaginatedVoiceListWritable = {
  next?: string | null;
  previous?: string | null;
  results: Array<Voice>;
  total?: number;
};

export type PaginatedWebhookListReadable = {
  next?: string | null;
  previous?: string | null;
  results: Array<WebhookReadable>;
  total?: number;
};

export type PaginatedWebhookListWritable = {
  next?: string | null;
  previous?: string | null;
  results: Array<WebhookWritable>;
  total?: number;
};

export type PaginatedultravoxV1CorpusDocumentList = {
  next?: string | null;
  previous?: string | null;
  results: Array<UltravoxV1CorpusDocument>;
  total?: number;
};

export type PaginatedultravoxV1CorpusList = {
  next?: string | null;
  previous?: string | null;
  results: Array<UltravoxV1Corpus>;
  total?: number;
};

export type PaginatedultravoxV1CorpusSourceList = {
  next?: string | null;
  previous?: string | null;
  results: Array<UltravoxV1CorpusSource>;
  total?: number;
};

export type PaginatedultravoxV1MessageList = {
  next?: string | null;
  previous?: string | null;
  results: Array<UltravoxV1Message>;
  total?: number;
};

export type PatchedApiKeyReadable = {
  readonly prefix?: string;
  readonly created?: string;
  readonly creator?: string | null;
  /**
   * A free-form name for the API key. Need not be unique. 50 characters max.
   */
  readonly name?: string;
  /**
   * Once API key expires, clients cannot use it anymore.
   */
  readonly expiryDate?: string | null;
  /**
   * If the API key is revoked, clients cannot use it anymore. (This cannot be undone.)
   */
  revoked?: boolean;
};

export type PatchedApiKeyWritable = {
  /**
   * If the API key is revoked, clients cannot use it anymore. (This cannot be undone.)
   */
  revoked?: boolean;
};

export type PatchedAgentReadable = {
  readonly agentId?: string;
  name?: string;
  readonly created?: string;
  callTemplate?: UltravoxV1CallTemplate | null;
  /**
   * Statistics about the agent's usage
   */
  readonly statistics?: {
    calls?: number;
  };
};

export type PatchedAgentWritable = {
  name?: string;
  callTemplate?: UltravoxV1CallTemplate | null;
};

export type PatchedSetTtsApiKeysRequest = {
  /**
   * Your ElevenLabs API key.
   * https://elevenlabs.io/app/settings/api-keys
   */
  elevenLabs?: string | null;
  /**
   * Your Cartesia API key.
   * https://play.cartesia.ai/keys
   */
  cartesia?: string | null;
  /**
   * Your PlayHT API key.
   * Note: This must come from play.ht, not play.ai. Their users are NOT interchangeable!
   * https://play.ht/studio/api-access
   */
  playHt?: string | null;
  /**
   * Your LMNT API key.
   * https://app.lmnt.com/account#api-keys
   */
  lmnt?: string | null;
};

export type PatchedWebhookReadable = {
  readonly webhookId?: string;
  readonly created?: string;
  url?: string;
  secrets?: Array<string>;
  events?: Array<EventsEnum>;
};

export type PatchedWebhookWritable = {
  url?: string;
  secrets?: Array<string>;
  events?: Array<EventsEnum>;
};

export type ToolReadable = {
  readonly toolId: string;
  name: string;
  readonly created: string;
  definition: UltravoxV1BaseToolDefinition;
  ownership: OwnershipEnum;
};

export type ToolWritable = {
  name: string;
  definition: UltravoxV1BaseToolDefinition;
  ownership: OwnershipEnum;
};

export type ToolHistoryReadable = {
  call: CallReadable;
  readonly errorCount: number;
};

export type ToolHistoryWritable = {
  call: CallWritable;
};

export type UsageResponseReadable = {
  dailyUsage: Array<BillingUsageDay>;
  /**
   * Total billed usage within the requested period in minutes.
   */
  readonly totalMinutes: number;
};

export type UsageResponseWritable = {
  dailyUsage: Array<BillingUsageDay>;
};

export type Voice = {
  readonly voiceId: string;
  readonly name: string;
  readonly description: string | null;
  readonly previewUrl: string | null;
  ownership: OwnershipEnum;
};

export type WebhookReadable = {
  readonly webhookId: string;
  readonly created: string;
  url: string;
  secrets?: Array<string>;
  events: Array<EventsEnum>;
};

export type WebhookWritable = {
  url: string;
  secrets?: Array<string>;
  events: Array<EventsEnum>;
};

/**
 * A CallTemplate that can be used to create Ultravox calls with shared properties.
 */
export type UltravoxV1CallTemplate = {
  /**
   * The name of the call template.
   */
  name?: string;
  /**
   * When the call template was created.
   */
  created?: string;
  /**
   * When the call template was last modified.
   */
  updated?: string;
  /**
   * The medium used for calls by default.
   */
  medium?: UltravoxV1CallMedium;
  /**
   * The medium initially used for calls by default. Defaults to voice.
   */
  initialOutputMedium?:
    | 'MESSAGE_MEDIUM_UNSPECIFIED'
    | 'MESSAGE_MEDIUM_VOICE'
    | 'MESSAGE_MEDIUM_TEXT';
  /**
   * A default timeout for joining calls. Defaults to 30 seconds.
   */
  joinTimeout?: string;
  /**
   * The default maximum duration of calls. Defaults to 1 hour.
   */
  maxDuration?: string;
  /**
   * The default voice activity detection settings for calls.
   */
  vadSettings?: UltravoxV1VadSettings;
  /**
   * Whether calls are recorded by default.
   */
  recordingEnabled?: boolean;
  /**
   * The default settings for the initial message to get a conversation started for calls.
   * Defaults to `agent: {}` which means the agent will start the conversation with an
   * (interruptible) greeting generated based on the system prompt and any initial messages.
   */
  firstSpeakerSettings?: UltravoxV1FirstSpeakerSettings;
  /**
   * The system prompt used for generations.
   * If multiple stages are defined for the call, this will be used only for stages without their own systemPrompt.
   */
  systemPrompt?: string;
  /**
   * The model temperature, between 0 and 1. Defaults to 0.
   * If multiple stages are defined for the call, this will be used only for stages without their own temperature.
   */
  temperature?: number;
  /**
   * The model used for generations. Defaults to fixie-ai/ultravox.
   * If multiple stages are defined for the call, this will be used only for stages without their own model.
   */
  model?: string;
  /**
   * The name or ID of the voice the agent should use for calls.
   * If multiple stages are defined for the call, this will be used only for stages without their own voice (or external_voice).
   */
  voice?: string;
  /**
   * A voice not known to Ultravox Realtime that can nonetheless be used for calls with this agent.
   * Your account must have an API key set for the provider of the voice.
   * Either this or `voice` may be set, but not both.
   */
  externalVoice?: UltravoxV1ExternalVoice;
  /**
   * A BCP47 language code that may be used to guide speech recognition and synthesis.
   * If multiple stages are defined for the call, this will be used only for stages without their own languageHint.
   */
  languageHint?: string;
  /**
   * What the agent should say immediately before hanging up if the call's time limit is reached.
   * If multiple stages are defined for the call, this will be used only for stages without their own timeExceededMessage.
   */
  timeExceededMessage?: string;
  /**
   * Messages spoken by the agent when the user is inactive for the specified duration.
   * Durations are cumulative, so a message m > 1 with duration 30s will be spoken 30 seconds after message m-1.
   * If multiple stages are defined for the call, this will be used only for stages without their own inactivityMessages.
   */
  inactivityMessages?: Array<UltravoxV1TimedMessage>;
  /**
   * The tools available to the agent for this call.
   * The following fields are treated as templates when converting to a CallTool.
   * * description
   * * static_parameters.value
   * * http.auth_headers.value
   * * http.auth_query_params.value
   * If multiple stages are defined for the call, this will be used only for stages without their own selectedTools.
   */
  selectedTools?: Array<UltravoxV1SelectedTool>;
  /**
   * Data connection configuration for calls created with this agent.
   */
  dataConnection?: UltravoxV1DataConnectionConfig;
  /**
   * JSON schema for the variables used in string templates. If unset, a default schema will
   * be created from the variables used in the string templates.
   * Call creation requests must provide context adhering to this schema.
   * The follow fields are treated as templates:
   * * system_prompt
   * * language_hint
   * * time_exceeded_message
   * * inactivity_messages.message
   * * selected_tools.description
   * * selected_tools.static_parameters.value
   * * selected_tools.http.auth_headers.value
   * * selected_tools.http.auth_query_params.value
   * If multiple stages are defined for the call, each must define its own context schema (or use the generated one).
   */
  contextSchema?: {
    [key: string]: unknown;
  };
};

/**
 * A queryable collection of documents. A corpus can be used to ground Ultravox
 * with factual content for a particular domain.
 */
export type UltravoxV1Corpus = {
  /**
   * The unique ID of this corpus.
   */
  corpusId?: string;
  /**
   * When this corpus was created.
   */
  created?: string;
  /**
   * The name of this corpus.
   */
  name?: string;
  /**
   * A description of this corpus.
   */
  description?: string;
  /**
   * The current stats for this corpus.
   */
  stats?: UltravoxV1CorpusStats;
};

/**
 * A single complete source of information included in a corpus. In the most
 * straight-forward case, this could be an uploaded PDF or a single webpage.
 * However, documents can also be created from other documents during processing,
 * for example turning an HTML page into a markdown document.
 */
export type UltravoxV1CorpusDocument = {
  /**
   * The id of the corpus in which this document is included.
   */
  corpusId?: string;
  /**
   * The id of the source that provides this document.
   */
  sourceId?: string;
  /**
   * The unique ID of this document.
   */
  documentId?: string;
  /**
   * When this document was created.
   */
  created?: string;
  /**
   * The MIME type of the document.
   * https://developer.mozilla.org/en-US/docs/Web/HTTP/MIME_types
   */
  mimeType?: string;
  /**
   * Metadata about the document.
   */
  metadata?: UltravoxV1CorpusDocumentMetadata;
  /**
   * The size of the document contents, in bytes.
   */
  sizeBytes?: string;
};

/**
 * A single result from a corpus query (corresponding to a chunk).
 */
export type UltravoxV1CorpusQueryResult = {
  /**
   * The content of the retrieved chunk.
   */
  content?: string;
  /**
   * The score of this chunk, with higher scores indicating better matches.
   */
  score?: number;
  /**
   * A citation for this chunk.
   */
  citation?: UltravoxV1CorpusQueryResultCitation;
};

/**
 * A source of documents for building a corpus. A source defines where documents
 * are pulled from.
 */
export type UltravoxV1CorpusSource = {
  /**
   * The id of this source's corpus.
   */
  corpusId?: string;
  /**
   * The unique ID of this source.
   */
  sourceId?: string;
  /**
   * When this source was created.
   */
  created?: string;
  /**
   * The name of this source.
   */
  name?: string;
  /**
   * A description of this source.
   */
  description?: string;
  /**
   * The current stats for this source.
   */
  stats?: UltravoxV1SourceStats;
  /**
   * DEPRECATED. Prefer setting crawl instead. If either crawl or upload is set, this field will be ignored.
   */
  loadSpec?: UltravoxV1CrawlSpec;
  /**
   * Allows loading documents by crawling the web.
   */
  crawl?: UltravoxV1CrawlSpec;
  /**
   * Allows loading from a uploaded document.
   */
  upload?: UltravoxV1UploadSpec;
};

/**
 * A message exchanged during a call.
 */
export type UltravoxV1Message = {
  /**
   * The message's role.
   */
  role?:
    | 'MESSAGE_ROLE_UNSPECIFIED'
    | 'MESSAGE_ROLE_USER'
    | 'MESSAGE_ROLE_AGENT'
    | 'MESSAGE_ROLE_TOOL_CALL'
    | 'MESSAGE_ROLE_TOOL_RESULT';
  /**
   * The message text for user and agent messages, tool arguments for tool_call messages, tool results for tool_result messages.
   */
  text?: string;
  /**
   * The invocation ID for tool messages. Used to pair tool calls with their results.
   */
  invocationId?: string;
  /**
   * The tool name for tool messages.
   */
  toolName?: string;
  /**
   * For failed tool calls, additional debugging information. While the text field is
   * presented to the model so it can respond to failures gracefully, the full details
   * are only exposed via the Ultravox REST API.
   */
  errorDetails?: string;
  /**
   * The medium of the message.
   */
  medium?:
    | 'MESSAGE_MEDIUM_UNSPECIFIED'
    | 'MESSAGE_MEDIUM_VOICE'
    | 'MESSAGE_MEDIUM_TEXT';
  /**
   * The index of the message within the call stage.
   */
  callStageMessageIndex?: number;
  /**
   * The call stage this message appeared in.
   */
  callStageId?: string;
  /**
   * If the message updated the call state, the new call state.
   */
  callState?: {
    [key: string]: unknown;
  };
  /**
   * The timespan during the call when this message occurred.
   * This is only set for messages that occurred during the call (stage)
   * and not for messages in the call's (call stage's) initial messages.
   */
  timespan?: UltravoxV1InCallTimespan;
};

/**
 * Represents a dynamically typed value which can be either null, a number, a string, a boolean, a recursive struct value, or a list of values.
 */
export type GoogleProtobufValue = unknown;

/**
 * A parameter that is automatically set by the system.
 */
export type UltravoxV1AutomaticParameter = {
  /**
   * The name of the parameter.
   */
  name?: string;
  /**
   * Where the parameter is used.
   */
  location?:
    | 'PARAMETER_LOCATION_UNSPECIFIED'
    | 'PARAMETER_LOCATION_QUERY'
    | 'PARAMETER_LOCATION_PATH'
    | 'PARAMETER_LOCATION_HEADER'
    | 'PARAMETER_LOCATION_BODY';
  /**
   * The value to set for the parameter.
   */
  knownValue?:
    | 'KNOWN_PARAM_UNSPECIFIED'
    | 'KNOWN_PARAM_CALL_ID'
    | 'KNOWN_PARAM_CONVERSATION_HISTORY'
    | 'KNOWN_PARAM_OUTPUT_SAMPLE_RATE'
    | 'KNOWN_PARAM_CALL_STATE';
};

/**
 * Details for invoking a tool expected to be implemented by the client.
 */
export type UltravoxV1BaseClientToolDetails = {
  [key: string]: unknown;
};

/**
 * Details for invoking a tool via a data connection.
 */
export type UltravoxV1BaseDataConnectionToolDetails = {
  [key: string]: unknown;
};

/**
 * Details for invoking a tool via HTTP.
 */
export type UltravoxV1BaseHttpToolDetails = {
  /**
   * The base URL pattern for the tool, possibly with placeholders for path parameters.
   */
  baseUrlPattern?: string;
  /**
   * The HTTP method for the tool.
   */
  httpMethod?: string;
};

/**
 * The base definition of a tool that can be used during a call. Exactly one
 * implementation (http or client) should be set.
 */
export type UltravoxV1BaseToolDefinition = {
  /**
   * The name of the tool, as presented to the model. Must match ^[a-zA-Z0-9_-]{1,64}$.
   */
  modelToolName?: string;
  /**
   * The description of the tool.
   */
  description?: string;
  /**
   * The parameters that the tool accepts.
   */
  dynamicParameters?: Array<UltravoxV1DynamicParameter>;
  /**
   * The static parameters added when the tool is invoked.
   */
  staticParameters?: Array<UltravoxV1StaticParameter>;
  /**
   * Additional parameters that are automatically set by the system when the tool is invoked.
   */
  automaticParameters?: Array<UltravoxV1AutomaticParameter>;
  /**
   * Requirements that must be fulfilled when creating a call for the tool to be used.
   */
  requirements?: UltravoxV1ToolRequirements;
  /**
   * The maximum amount of time the tool is allowed for execution. The conversation is frozen
   * while tools run, so prefer sticking to the default unless you're comfortable with that
   * consequence. If your tool is too slow for the default and can't be made faster, still try to
   * keep this timeout as low as possible.
   */
  timeout?: string;
  /**
   * The tool is guaranteed to be non-mutating, repeatable, and free of side-effects. Such tools
   * can safely be executed speculatively, reducing their effective latency. However, the fact they
   * were called may not be reflected in the call history if their result ends up unused.
   */
  precomputable?: boolean;
  /**
   * Details for an HTTP tool.
   */
  http?: UltravoxV1BaseHttpToolDetails;
  /**
   * Details for a client-implemented tool. Only body parameters are allowed
   * for client tools.
   */
  client?: UltravoxV1BaseClientToolDetails;
  /**
   * Details for a tool implemented via a data connection websocket. Only body
   * parameters are allowed for data connection tools.
   */
  dataConnection?: UltravoxV1BaseDataConnectionToolDetails;
  /**
   * Indicates the default for how the agent should proceed after the tool is invoked.
   * Can be overridden by the tool implementation via the X-Ultravox-Agent-Reaction
   * header.
   */
  defaultReaction?:
    | 'AGENT_REACTION_UNSPECIFIED'
    | 'AGENT_REACTION_SPEAKS'
    | 'AGENT_REACTION_LISTENS'
    | 'AGENT_REACTION_SPEAKS_ONCE';
  /**
   * Static response to a tool. When this is used, this response will be returned
   * without waiting for the tool's response.
   */
  staticResponse?: UltravoxV1StaticToolResponse;
};

/**
 * Details about a call's protocol. By default, calls occur over WebRTC using
 * the Ultravox client SDK. Setting a different call medium will prepare the
 * server for a call using a different protocol.
 * At most one call medium may be set.
 */
export type UltravoxV1CallMedium = {
  /**
   * The call will use WebRTC with the Ultravox client SDK.
   * This is the default.
   */
  webRtc?: UltravoxV1CallMediumWebRtcMedium;
  /**
   * The call will use Twilio's "Media Streams" protocol.
   * Once you have a join URL from starting a call, include it in your
   * TwiML like so:
   * <Connect><Stream url=${your-join-url} /></Connect>
   * This works for both inbound and outbound calls.
   */
  twilio?: UltravoxV1CallMediumTwilioMedium;
  /**
   * The call will use a plain websocket connection. This is unlikely to yield an acceptable user
   * experience if used from a browser or mobile client, but may be suitable for a
   * server-to-server connection. This option provides a simple way to connect your own server to
   * an Ultravox inference instance.
   */
  serverWebSocket?: UltravoxV1CallMediumWebSocketMedium;
  /**
   * The call will use Telnyx's media streaming protocol.
   * Once you have a join URL from starting a call, include it in your
   * TexML like so:
   * <Connect><Stream url=${your-join-url} bidirectionalMode="rtp" /></Connect>
   * This works for both inbound and outbound calls.
   */
  telnyx?: UltravoxV1CallMediumTelnyxMedium;
  /**
   * The call will use Plivo's AudioStreams protocol.
   * Once you have a join URL from starting a call, include it in your
   * Plivo XML like so:
   * <Stream keepCallAlive="true" bidirectional="true" contentType="audio/x-l16;rate=16000">${your-join-url}</Stream>
   * This works for both inbound and outbound calls.
   */
  plivo?: UltravoxV1CallMediumPlivoMedium;
  /**
   * The call will use Exotel's "Voicebot" protocol.
   * Once you have a join URL from starting a call, provide it to Exotel as the wss target URL
   * for your Voicebot (either directly or more likely dynamically from your own server).
   */
  exotel?: UltravoxV1CallMediumExotelMedium;
  /**
   * The call will be connected using Session Initiation Protocol (SIP). Note that SIP incurs
   * additional charges and must be enabled for your account.
   */
  sip?: UltravoxV1CallMediumSipMedium;
};

/**
 * Details for a Exotel call.
 */
export type UltravoxV1CallMediumExotelMedium = {
  [key: string]: unknown;
};

/**
 * Details for a Plivo call.
 */
export type UltravoxV1CallMediumPlivoMedium = {
  [key: string]: unknown;
};

/**
 * Details for a SIP call. Exactly one of incoming or outgoing must be set.
 */
export type UltravoxV1CallMediumSipMedium = {
  /**
   * Details for an incoming SIP call.
   */
  incoming?: UltravoxV1SipMediumSipIncoming;
  /**
   * Details for an outgoing SIP call. Ultravox will initiate this call (and there will be no joinUrl).
   */
  outgoing?: UltravoxV1SipMediumSipOutgoing;
};

/**
 * Details for a Telnyx call.
 */
export type UltravoxV1CallMediumTelnyxMedium = {
  [key: string]: unknown;
};

/**
 * Details for a Twilio call.
 */
export type UltravoxV1CallMediumTwilioMedium = {
  [key: string]: unknown;
};

/**
 * Details for a WebRTC call.
 */
export type UltravoxV1CallMediumWebRtcMedium = {
  [key: string]: unknown;
};

/**
 * Details for a WebSocket call.
 */
export type UltravoxV1CallMediumWebSocketMedium = {
  /**
   * The sample rate for input (user) audio. Required.
   */
  inputSampleRate?: number;
  /**
   * The desired sample rate for output (agent) audio. If unset, defaults to the input_sample_rate.
   */
  outputSampleRate?: number;
  /**
   * The size of the client-side audio buffer in milliseconds. Smaller buffers allow for faster
   * interruptions but may cause audio underflow if network latency fluctuates too greatly. For
   * the best of both worlds, set this to some large value (e.g. 30000) and implement support for
   * playback_clear_buffer messages. Defaults to 60.
   */
  clientBufferSizeMs?: number;
};

/**
 * A tool as used for a particular call (omitting auth details).
 */
export type UltravoxV1CallTool = {
  /**
   * The description of the tool.
   */
  description?: string;
  /**
   * The parameters presented to the model.
   */
  dynamicParameters?: Array<UltravoxV1DynamicParameter>;
  /**
   * Parameters added unconditionally when the tool is invoked.
   */
  staticParameters?: Array<UltravoxV1StaticParameter>;
  /**
   * Parameters automatically set by the system.
   */
  automaticParameters?: Array<UltravoxV1AutomaticParameter>;
  /**
   * The maximum amount of time the tool is allowed for execution. The conversation is frozen
   * while tools run, so prefer sticking to the default unless you're comfortable with that
   * consequence. If your tool is too slow for the default and can't be made faster, still try to
   * keep this timeout as low as possible.
   */
  timeout?: string;
  /**
   * The tool is guaranteed to be non-mutating, repeatable, and free of side-effects. Such tools
   * can safely be executed speculatively, reducing their effective latency. However, the fact they
   * were called may not be reflected in the call history if their result ends up unused.
   */
  precomputable?: boolean;
  /**
   * Details for an HTTP tool.
   */
  http?: UltravoxV1HttpCallToolDetails;
  /**
   * Details for a client-implemented tool. Only body parameters are allowed
   * for client tools.
   */
  client?: UltravoxV1ClientCallToolDetails;
  /**
   * Details for invoking a tool via a data connection.
   */
  dataConnection?: UltravoxV1DataConnectionCallToolDetails;
  /**
   * Indicates the default for how the agent should proceed after the tool is invoked.
   * Can be overridden by the tool implementation via the X-Ultravox-Agent-Reaction
   * header.
   */
  defaultReaction?:
    | 'AGENT_REACTION_UNSPECIFIED'
    | 'AGENT_REACTION_SPEAKS'
    | 'AGENT_REACTION_LISTENS'
    | 'AGENT_REACTION_SPEAKS_ONCE';
  /**
   * Static response to a tool. When this is used, this response will be returned
   * without waiting for the tool's response.
   */
  staticResponse?: UltravoxV1StaticToolResponse;
};

/**
 * Specification for a voice served by Cartesia.
 */
export type UltravoxV1CartesiaVoice = {
  /**
   * The ID of the voice in Cartesia.
   */
  voiceId?: string;
  /**
   * The Cartesia model to use.
   */
  model?: string;
  /**
   * The speaking rate. Must be between -1 and 1. Defaults to 0.
   * See https://docs.cartesia.ai/api-reference/tts/tts#send.Generation%20Request.voice.Ttsrequest%20ID%20Specifier.__experimental_controls.speed
   */
  speed?: number;
  /**
   * See https://docs.cartesia.ai/api-reference/tts/tts#send.Generation%20Request.voice.Ttsrequest%20ID%20Specifier.__experimental_controls.emotion
   */
  emotion?: string;
  /**
   * See https://docs.cartesia.ai/api-reference/tts/tts#send.Generation%20Request.voice.Ttsrequest%20ID%20Specifier.__experimental_controls.emotion
   */
  emotions?: Array<string>;
};

/**
 * Details for a CallTool implemented by the client.
 */
export type UltravoxV1ClientCallToolDetails = {
  [key: string]: unknown;
};

/**
 * Metadata about a document. This is typically not included in the document's
 * chunks, but can be used for filtering or citations.
 * Derived documents inherit metadata from their source documents in general.
 */
export type UltravoxV1CorpusDocumentMetadata = {
  /**
   * The public URL of the document, if any.
   */
  publicUrl?: string;
  /**
   * The BCP47 language code of the document, if known.
   */
  language?: string;
  /**
   * The title of the document, if known.
   */
  title?: string;
  /**
   * A description of the document, if known.
   */
  description?: string;
  /**
   * The timestamp that the document was published, if known.
   */
  published?: string;
};

/**
 * A citation for a query result.
 */
export type UltravoxV1CorpusQueryResultCitation = {
  /**
   * The source that provided the document from which this chunk was retrieved.
   */
  sourceId?: string;
  /**
   * The document from which this chunk was retrieved.
   */
  documentId?: string;
  /**
   * The public URL of the document, if any.
   */
  publicUrl?: string;
  /**
   * The title of the document, if known.
   */
  title?: string;
};

/**
 * The current stats for a corpus. This gives an indication of whether the
 * corpus is queryable and what sorts of results can be expected.
 */
export type UltravoxV1CorpusStats = {
  /**
   * The current status of this corpus, indicating whether it is queryable.
   */
  status?:
    | 'CORPUS_STATUS_UNSPECIFIED'
    | 'CORPUS_STATUS_EMPTY'
    | 'CORPUS_STATUS_INITIALIZING'
    | 'CORPUS_STATUS_READY'
    | 'CORPUS_STATUS_UPDATING';
  /**
   * The last time the contents of this corpus were updated.
   */
  lastUpdated?: string;
  /**
   * The number of chunks in this corpus. Chunks are subsets of documents.
   */
  numChunks?: number;
  /**
   * The number of documents in this corpus.
   */
  numDocs?: number;
  /**
   * The number of vectors in this corpus. Vectors are used for semantic search.
   * Multiple vectors may correspond to a single chunk.
   */
  numVectors?: number;
};

/**
 * The specification of how to acquire documents for this source.
 */
export type UltravoxV1CrawlSpec = {
  /**
   * The maximum number of documents to ingest.
   */
  maxDocuments?: number;
  /**
   * The maximum size of an individual document in bytes.
   */
  maxDocumentBytes?: number;
  /**
   * The types of documents to keep. Any documents surfaced during loading
   * that don't match this filter will be discarded. If not set, Ultravox will
   * choose a default that includes types known to provide real value.
   */
  relevantDocumentTypes?: UltravoxV1MimeTypeFilter;
  /**
   * The list of start URLs for crawling. If max_depth is 1, only these URLs will
   * be fetched. Otherwise, links from these urls will be followed up to the
   * max_depth.
   */
  startUrls?: Array<string>;
  /**
   * The maximum depth of links to traverse. Use 1 to only fetch the startUrls,
   * 2 to fetch the startUrls and documents directly linked from them, 3 to
   * additionally fetch documents linked from those (excluding anything already
   * seen), etc.
   */
  maxDepth?: number;
};

/**
 * Configuration for audio in data connections
 */
export type UltravoxV1DataConnectionAudioConfig = {
  /**
   * The sample rate of the audio stream. If not set, will default to 16000.
   */
  sampleRate?: number;
  /**
   * The audio channel mode to use. CHANNEL_MODE_MIXED will combine user and agent audio
   * into a single mono output while CHANNEL_MODE_SEPARATED will result in stereo audio
   * where user and agent are separated. The latter is the default.
   */
  channelMode?:
    | 'CHANNEL_MODE_UNSPECIFIED'
    | 'CHANNEL_MODE_MIXED'
    | 'CHANNEL_MODE_SEPARATED';
};

/**
 * Details for invoking a tool via a data connection.
 */
export type UltravoxV1DataConnectionCallToolDetails = {
  [key: string]: unknown;
};

/**
 * Data connection enables an auxiliary websocket for streaming data messages.
 */
export type UltravoxV1DataConnectionConfig = {
  /**
   * The websocket URL to which the session will connect to stream data messages.
   */
  websocketUrl?: string;
  /**
   * Audio configuration for the data connection. If not set, no audio will be sent.
   */
  audioConfig?: UltravoxV1DataConnectionAudioConfig;
};

/**
 * A dynamic parameter the tool accepts that may be set by the model.
 */
export type UltravoxV1DynamicParameter = {
  /**
   * The name of the parameter.
   */
  name?: string;
  /**
   * Where the parameter is used.
   */
  location?:
    | 'PARAMETER_LOCATION_UNSPECIFIED'
    | 'PARAMETER_LOCATION_QUERY'
    | 'PARAMETER_LOCATION_PATH'
    | 'PARAMETER_LOCATION_HEADER'
    | 'PARAMETER_LOCATION_BODY';
  /**
   * The JsonSchema definition of the parameter. This typically
   * includes things like type, description, enum values, format,
   * other restrictions, etc.
   */
  schema?: {
    [key: string]: unknown;
  };
  /**
   * Whether the parameter is required.
   */
  required?: boolean;
};

/**
 * Specification for a voice served by ElevenLabs.
 */
export type UltravoxV1ElevenLabsVoice = {
  /**
   * The ID of the voice in ElevenLabs.
   */
  voiceId?: string;
  /**
   * The ElevenLabs model to use.
   */
  model?: string;
  /**
   * The speaking rate. Must be between 0.7 and 1.2. Defaults to 1.
   * See https://elevenlabs.io/docs/api-reference/text-to-speech/convert#request.body.voice_settings.speed
   */
  speed?: number;
  /**
   * See https://elevenlabs.io/docs/api-reference/text-to-speech/convert#request.body.voice_settings.use_speaker_boost
   */
  useSpeakerBoost?: boolean;
  /**
   * See https://elevenlabs.io/docs/api-reference/text-to-speech/convert#request.body.voice_settings.style
   */
  style?: number;
  /**
   * See https://elevenlabs.io/docs/api-reference/text-to-speech/convert#request.body.voice_settings.similarity_boost
   */
  similarityBoost?: number;
  /**
   * See https://elevenlabs.io/docs/api-reference/text-to-speech/convert#request.body.voice_settings.stability
   */
  stability?: number;
  /**
   * See https://elevenlabs.io/docs/api-reference/text-to-speech/convert#request.body.pronunciation_dictionary_locators
   */
  pronunciationDictionaries?: Array<UltravoxV1ElevenLabsVoicePronunciationDictionaryReference>;
  /**
   * See https://elevenlabs.io/docs/api-reference/text-to-speech/convert#request.query.optimize_streaming_latency.optimize_streaming_latency
   */
  optimizeStreamingLatency?: number;
  /**
   * The maximum sample rate Ultravox will try to use. ElevenLabs limits your allowed sample rate
   * based on your tier. See https://elevenlabs.io/pricing#pricing-table (and click "Show API details")
   */
  maxSampleRate?: number;
};

/**
 * A reference to a pronunciation dictionary within ElevenLabs.
 */
export type UltravoxV1ElevenLabsVoicePronunciationDictionaryReference = {
  /**
   * The dictionary's ID.
   */
  dictionaryId?: string;
  /**
   * The dictionary's version.
   */
  versionId?: string;
};

/**
 * A voice not known to Ultravox Realtime that can nonetheless be used for a call.
 * Such voices are significantly less validated than normal voices and you'll be
 * responsible for your own TTS-related errors.
 * Exactly one field must be set.
 */
export type UltravoxV1ExternalVoice = {
  /**
   * A voice served by ElevenLabs.
   */
  elevenLabs?: UltravoxV1ElevenLabsVoice;
  /**
   * A voice served by Cartesia.
   */
  cartesia?: UltravoxV1CartesiaVoice;
  /**
   * A voice served by PlayHT.
   */
  playHt?: UltravoxV1PlayHtVoice;
  /**
   * A voice served by LMNT.
   */
  lmnt?: UltravoxV1LmntVoice;
  /**
   * A voice served by a generic REST-based TTS API.
   */
  generic?: UltravoxV1GenericVoice;
};

/**
 * A fallback for the case when the user is expected to speak first but doesn't.
 */
export type UltravoxV1FallbackAgentGreeting = {
  /**
   * How long the agent should wait before starting the conversation itself.
   */
  delay?: string;
  /**
   * A specific greeting the agent should say.
   */
  text?: string;
  /**
   * A prompt for the agent to generate a greeting.
   */
  prompt?: string;
};

/**
 * Settings for the initial message to get a conversation started.
 * Exactly one of user or agent should be set. The default is agent
 * (unless firstSpeaker is also set, in which case the default will
 * match that).
 */
export type UltravoxV1FirstSpeakerSettings = {
  /**
   * If set, the user should speak first.
   */
  user?: UltravoxV1FirstSpeakerSettingsUserGreeting;
  /**
   * If set, the agent should speak first.
   */
  agent?: UltravoxV1FirstSpeakerSettingsAgentGreeting;
};

/**
 * Additional properties for when the agent speaks first.
 */
export type UltravoxV1FirstSpeakerSettingsAgentGreeting = {
  /**
   * Whether the user should be prevented from interrupting the agent's first message.
   * Defaults to false (meaning the agent is interruptible as usual).
   */
  uninterruptible?: boolean;
  /**
   * A specific greeting the agent should say.
   */
  text?: string;
  /**
   * A prompt for the agent to generate a greeting.
   */
  prompt?: string;
  /**
   * If set, the agent will wait this long before starting its greeting. This may be useful
   * for ensuring the user is ready.
   */
  delay?: string;
};

/**
 * Additional properties for when the user speaks first.
 */
export type UltravoxV1FirstSpeakerSettingsUserGreeting = {
  /**
   * If set, the agent will start the conversation itself if the user doesn't start
   * speaking within the given delay.
   */
  fallback?: UltravoxV1FallbackAgentGreeting;
};

/**
 * Specification for a voice served by some generic REST-based TTS API. The API must
 * accept an application/json POST request (as defined below) and return either WAV
 * or raw PCM audio with an appropriate Content-Type response header.
 * Note that this simple API implies a lack of either input streaming or audio timing
 * information, so more specific voice types are preferable when available.
 */
export type UltravoxV1GenericVoice = {
  /**
   * The endpoint to which requests are sent.
   */
  url?: string;
  /**
   * Headers to include in the request.
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * The request body to send. Some field should include a placeholder for text
   * represented as {text}. The placeholder will be replaced with the text to synthesize.
   */
  body?: {
    [key: string]: unknown;
  };
  /**
   * The sample rate of the audio returned by the API.
   */
  responseSampleRate?: number;
  /**
   * An estimate of the speaking rate of the returned audio in words per minute. This is
   * used for transcript timing while audio is streamed in the response. (Once the response
   * is complete, Ultravox Realtime uses the real audio duration to adjust the timing.)
   * Defaults to 150 and is unused for non-streaming responses.
   */
  responseWordsPerMinute?: number;
  /**
   * The real mime type of the audio returned by the API. If unset, the Content-Type response header
   * will be used. This is useful for APIs whose response bodies don't strictly adhere to what the
   * API claims via header. For example, if your API claims to return audio/wav but omits the WAV
   * header (thus really returning raw PCM), set this to audio/l16.
   */
  responseMimeType?: string;
};

/**
 * A security requirement that will cause an API key to be added to the header.
 */
export type UltravoxV1HeaderApiKeyRequirement = {
  /**
   * The name of the header.
   */
  name?: string;
};

/**
 * A security requirement that will cause an HTTP authentication header to be added.
 */
export type UltravoxV1HttpAuthRequirement = {
  /**
   * The scheme of the HTTP authentication, e.g. "Bearer".
   */
  scheme?: string;
};

/**
 * Details for a CallTool implemented via HTTP requests.
 */
export type UltravoxV1HttpCallToolDetails = {
  /**
   * The base URL pattern for the tool, possibly with placeholders for path parameters.
   */
  baseUrlPattern?: string;
  /**
   * The HTTP method for the tool.
   */
  httpMethod?: string;
  /**
   * Auth headers added when the tool is invoked.
   */
  authHeaders?: Array<string>;
  /**
   * Auth query parameters added when the tool is invoked.
   */
  authQueryParams?: Array<string>;
  /**
   * If the tool requires a call token, the scopes that must be present in the token.
   * If this is empty, no call token will be created.
   */
  callTokenScopes?: Array<string>;
};

/**
 * A timespan during a call.
 */
export type UltravoxV1InCallTimespan = {
  /**
   * The offset relative to the start of the call.
   */
  start?: string;
  /**
   * The offset relative to the start of the call.
   */
  end?: string;
};

/**
 * Specification for a voice served by LMNT.
 */
export type UltravoxV1LmntVoice = {
  /**
   * The ID of the voice in LMNT.
   */
  voiceId?: string;
  /**
   * The LMNT model to use.
   */
  model?: string;
  /**
   * The speaking rate. Must be between 0.25 and 2. Defaults to 1.
   * See https://docs.lmnt.com/api-reference/speech/synthesize-speech-bytes#body-speed
   */
  speed?: number;
  /**
   * See https://docs.lmnt.com/api-reference/speech/synthesize-speech-bytes#body-conversational
   */
  conversational?: boolean;
};

/**
 * A Filter to apply to mime types.
 */
export type UltravoxV1MimeTypeFilter = {
  /**
   * Mime types must be in this set to be kept.
   */
  include?: UltravoxV1MimeTypeSet;
  /**
   * Mime types must not be in this set to be kept.
   */
  exclude?: UltravoxV1MimeTypeSet;
};

/**
 * A set of mime types. Entries may be a full mime type (e.g. "text/html") or a
 * type without a subtype (e.g. "text"). Entries without a subtype will match
 * all subtypes (e.g. "text" will match "text/html", "text/plain", etc.).
 */
export type UltravoxV1MimeTypeSet = {
  /**
   * The mime types in this set.
   */
  mimeTypes?: Array<string>;
};

/**
 * Specification for a voice served by PlayHT.
 */
export type UltravoxV1PlayHtVoice = {
  /**
   * The "user id" for the PlayHT API. This must be the user who owns the Play API key
   * associated with your Ultravox account.
   */
  userId?: string;
  /**
   * The ID of the voice in PlayHT. Typically an s3 location.
   */
  voiceId?: string;
  /**
   * The PlayHT model (aka "engine") to use.
   */
  model?: string;
  /**
   * The speaking rate. Must be between 0 and 5. Defaults to 1.
   */
  speed?: number;
  /**
   * See https://docs.play.ht/reference/api-generate-tts-audio-stream.
   */
  quality?: string;
  /**
   * See https://docs.play.ht/reference/api-generate-tts-audio-stream.
   */
  temperature?: number;
  /**
   * See https://docs.play.ht/reference/api-generate-tts-audio-stream.
   */
  emotion?: number;
  /**
   * See https://docs.play.ht/reference/api-generate-tts-audio-stream.
   */
  voiceGuidance?: number;
  /**
   * See https://docs.play.ht/reference/api-generate-tts-audio-stream.
   */
  styleGuidance?: number;
  /**
   * See https://docs.play.ht/reference/api-generate-tts-audio-stream.
   */
  textGuidance?: number;
  /**
   * See https://docs.play.ht/reference/api-generate-tts-audio-stream.
   */
  voiceConditioningSeconds?: number;
};

/**
 * A security requirement that will cause an API key to be added to the query string.
 */
export type UltravoxV1QueryApiKeyRequirement = {
  /**
   * The name of the query parameter.
   */
  name?: string;
};

/**
 * A request to query a corpus.
 */
export type UltravoxV1QueryCorpusRequest = {
  /**
   * The query to run.
   */
  query?: string;
  /**
   * The maximum number of results to return.
   */
  maxResults?: number;
};

/**
 * The different options for satisfying a tool's security requirements.
 */
export type UltravoxV1SecurityOptions = {
  /**
   * The options for security. Only one must be met. The first one that can be
   * satisfied will be used in general. The single exception to this rule is
   * that we always prefer a non-empty set of requirements over an empty set
   * unless no non-empty set can be satisfied.
   */
  options?: Array<UltravoxV1SecurityRequirements>;
};

/**
 * A single security requirement that must be met for a tool to be available. Exactly one
 * of query_api_key, header_api_key, or http_auth should be set.
 */
export type UltravoxV1SecurityRequirement = {
  /**
   * An API key must be added to the query string.
   */
  queryApiKey?: UltravoxV1QueryApiKeyRequirement;
  /**
   * An API key must be added to a custom header.
   */
  headerApiKey?: UltravoxV1HeaderApiKeyRequirement;
  /**
   * The HTTP authentication header must be added.
   */
  httpAuth?: UltravoxV1HttpAuthRequirement;
};

/**
 * The security requirements for a request. All requirements must be met.
 */
export type UltravoxV1SecurityRequirements = {
  /**
   * Requirements keyed by name.
   */
  requirements?: {
    [key: string]: UltravoxV1SecurityRequirement;
  };
  /**
   * An additional special security requirement that can be automatically fulfilled
   * during call creation. If a tool has this requirement set, a token identifying
   * the call and relevant scopes will be created during call creation and set as
   * an X-Ultravox-Call-Token header when the tool is invoked.
   * Such tokens are only verifiable by the Ultravox service and primarily exist
   * for built-in tools (though it's possible for third-party tools that wrap a
   * built-in tool to make use of them as well).
   */
  ultravoxCallTokenRequirement?: UltravoxV1UltravoxCallTokenRequirement;
};

/**
 * A tool selected for a particular call. Exactly one of tool_id, tool_name, or
 * temporary_tool should be set.
 */
export type UltravoxV1SelectedTool = {
  /**
   * The ID of an existing base tool.
   */
  toolId?: string;
  /**
   * The name of an existing base tool. The name must uniquely identify the tool.
   */
  toolName?: string;
  /**
   * A temporary tool definition, available only for this call (and subsequent
   * calls created using priorCallId without overriding selected tools). Exactly one
   * implementation (http or client) should be set. See the 'Base Tool Definition'
   * schema for more details.
   */
  temporaryTool?: UltravoxV1BaseToolDefinition;
  /**
   * An override for the model_tool_name. This is primarily useful when using
   * multiple instances of the same durable tool (presumably with different
   * parameter overrides.) The set of tools used within a call must have a unique
   * set of model names and every name must match this pattern: ^[a-zA-Z0-9_-]{1,64}$.
   */
  nameOverride?: string;
  /**
   * An override for the tool's description, as presented to the model. This is primarily
   * useful when using a built-in tool whose description you want to tweak to better fit
   * the rest of your prompt.
   */
  descriptionOverride?: string;
  /**
   * Auth tokens used to satisfy the tool's security requirements.
   */
  authTokens?: {
    [key: string]: string;
  };
  /**
   * Static values to use in place of dynamic parameters. Any parameter included
   * here will be hidden from the model and the static value will be used instead.
   * Some tools may require certain parameters to be overridden, but any parameter
   * can be overridden regardless of whether it is required to be.
   */
  parameterOverrides?: {
    [key: string]: GoogleProtobufValue;
  };
  /**
   * For internal use. Relates this tool to a stage transition definition within a call template for attribution.
   */
  transitionId?: string;
};

/**
 * Details for an incoming SIP call.
 */
export type UltravoxV1SipMediumSipIncoming = {
  [key: string]: unknown;
};

/**
 * Details for an outgoing SIP call.
 */
export type UltravoxV1SipMediumSipOutgoing = {
  /**
   * The SIP URI to connect to. (Phone numbers are not allowed.)
   */
  to?: string;
  /**
   * The SIP URI to connect from. This is the "from" field in the SIP INVITE.
   */
  from?: string;
  /**
   * The SIP username to use for authentication.
   */
  username?: string;
  /**
   * The password for the specified username.
   */
  password?: string;
};

/**
 * The current stats for a source.
 */
export type UltravoxV1SourceStats = {
  /**
   * The current status of this source, indicating whether it affects queries.
   */
  status?:
    | 'SOURCE_STATUS_UNSPECIFIED'
    | 'SOURCE_STATUS_INITIALIZING'
    | 'SOURCE_STATUS_READY'
    | 'SOURCE_STATUS_UPDATING';
  /**
   * When this source last finished contributing contents to its corpus.
   */
  lastUpdated?: string;
  /**
   * The number of documents in this source. This includes both loaded documents
   * and derived documents.
   */
  numDocs?: number;
};

/**
 * A request to start a call with an existing agent.
 */
export type UltravoxV1StartAgentCallRequest = {
  /**
   * Context for filling any mustache templates for the call.
   */
  templateContext?: {
    [key: string]: unknown;
  };
  /**
   * The conversation history to start from for this call.
   */
  initialMessages?: Array<UltravoxV1Message>;
  /**
   * Optional metadata key-value pairs to associate with the call. All values must be strings.
   * Keys may not start with "ultravox.", which is reserved for system-provided metadata.
   */
  metadata?: {
    [key: string]: string;
  };
  /**
   * The (overridden) medium used for this call.
   */
  medium?: UltravoxV1CallMedium;
  /**
   * The (overridden) timeout for joining this call.
   */
  joinTimeout?: string;
  /**
   * The (overridden) maximum duration of this call.
   */
  maxDuration?: string;
  /**
   * The (overridden) setting for whether the call should be recorded.
   */
  recordingEnabled?: boolean;
  /**
   * The (overridden) medium initially used by the agent. May be altered by the client later.
   */
  initialOutputMedium?:
    | 'MESSAGE_MEDIUM_UNSPECIFIED'
    | 'MESSAGE_MEDIUM_VOICE'
    | 'MESSAGE_MEDIUM_TEXT';
  /**
   * The (overridden) settings for the initial message to get a conversation started.
   * Defaults to `agent: {}` which means the agent will start the conversation with an
   * (interruptible) greeting generated based on the system prompt and any initial messages.
   * (If first_speaker is set and this is not, first_speaker will be used instead.)
   */
  firstSpeakerSettings?: UltravoxV1FirstSpeakerSettings;
  /**
   * The (overridden) data connection configuration.
   */
  dataConnection?: UltravoxV1DataConnectionConfig;
  /**
   * Experimental settings for the call.
   */
  experimentalSettings?: {
    [key: string]: unknown;
  };
};

/**
 * A request to start a call.
 */
export type UltravoxV1StartCallRequest = {
  /**
   * The system prompt provided to the model during generations.
   */
  systemPrompt?: string;
  /**
   * The model temperature, between 0 and 1. Defaults to 0.
   */
  temperature?: number;
  /**
   * The model used for generations. Defaults to fixie-ai/ultravox.
   */
  model?: string;
  /**
   * The ID (or name if unique) of the voice the agent should use for this call.
   */
  voice?: string;
  /**
   * A voice not known to Ultravox Realtime that can nonetheless be used for this call.
   * Your account must have an API key set for the provider of the voice.
   * Either this or `voice` may be set, but not both.
   */
  externalVoice?: UltravoxV1ExternalVoice;
  /**
   * A BCP47 language code that may be used to guide speech recognition and synthesis.
   */
  languageHint?: string;
  /**
   * The conversation history to start from for this call.
   */
  initialMessages?: Array<UltravoxV1Message>;
  /**
   * A timeout for joining the call. Defaults to 30 seconds.
   */
  joinTimeout?: string;
  /**
   * The maximum duration of the call. Defaults to 1 hour.
   */
  maxDuration?: string;
  /**
   * What the agent should say immediately before hanging up if the call's time limit is reached.
   */
  timeExceededMessage?: string;
  /**
   * Messages spoken by the agent when the user is inactive for the specified duration.
   * Durations are cumulative, so a message m > 1 with duration 30s will be spoken 30 seconds after message m-1.
   */
  inactivityMessages?: Array<UltravoxV1TimedMessage>;
  /**
   * The tools available to the agent for (the first stage of) this call.
   */
  selectedTools?: Array<UltravoxV1SelectedTool>;
  /**
   * The medium used for this call.
   */
  medium?: UltravoxV1CallMedium;
  /**
   * Whether the call should be recorded.
   */
  recordingEnabled?: boolean;
  /**
   * Who should talk first when the call starts. Typically set to FIRST_SPEAKER_USER for outgoing
   * calls and left as the default (FIRST_SPEAKER_AGENT) otherwise.
   * Deprecated. Prefer `firstSpeakerSettings`. If both are set, they must match.
   */
  firstSpeaker?:
    | 'FIRST_SPEAKER_UNSPECIFIED'
    | 'FIRST_SPEAKER_AGENT'
    | 'FIRST_SPEAKER_USER';
  /**
   * Indicates whether a transcript is optional for the call.
   */
  transcriptOptional?: boolean;
  /**
   * The medium to use for the call initially. May be altered by the client later.
   * Defaults to voice.
   */
  initialOutputMedium?:
    | 'MESSAGE_MEDIUM_UNSPECIFIED'
    | 'MESSAGE_MEDIUM_VOICE'
    | 'MESSAGE_MEDIUM_TEXT';
  /**
   * VAD settings for the call.
   */
  vadSettings?: UltravoxV1VadSettings;
  /**
   * The settings for the initial message to get a conversation started.
   * Defaults to `agent: {}` which means the agent will start the conversation with an
   * (interruptible) greeting generated based on the system prompt and any initial messages.
   * (If first_speaker is set and this is not, first_speaker will be used instead.)
   */
  firstSpeakerSettings?: UltravoxV1FirstSpeakerSettings;
  /**
   * Experimental settings for the call.
   */
  experimentalSettings?: {
    [key: string]: unknown;
  };
  /**
   * Optional metadata key-value pairs to associate with the call. All values must be strings.
   * Keys may not start with "ultravox.", which is reserved for system-provided metadata.
   */
  metadata?: {
    [key: string]: string;
  };
  /**
   * The initial state of the call stage which is readable/writable by tools.
   */
  initialState?: {
    [key: string]: unknown;
  };
  /**
   * Data connection configuration.
   */
  dataConnection?: UltravoxV1DataConnectionConfig;
};

/**
 * A static parameter that is unconditionally added when the tool is invoked. This
 * parameter is not exposed to or set by the model.
 */
export type UltravoxV1StaticParameter = {
  /**
   * The name of the parameter.
   */
  name?: string;
  /**
   * Where the parameter is used.
   */
  location?:
    | 'PARAMETER_LOCATION_UNSPECIFIED'
    | 'PARAMETER_LOCATION_QUERY'
    | 'PARAMETER_LOCATION_PATH'
    | 'PARAMETER_LOCATION_HEADER'
    | 'PARAMETER_LOCATION_BODY';
  /**
   * The value of the parameter.
   */
  value?: GoogleProtobufValue;
};

/**
 * A predefined, static response for a tool. When a tool has a static response, it
 * can be returned immediately, without waiting for full tool execution.
 */
export type UltravoxV1StaticToolResponse = {
  /**
   * The predefined text response to be returned immediately
   */
  responseText?: string;
};

/**
 * A message the agent should say after some duration. The duration's meaning
 * varies depending on the context.
 */
export type UltravoxV1TimedMessage = {
  /**
   * The duration after which the message should be spoken.
   */
  duration?: string;
  /**
   * The message to speak.
   */
  message?: string;
  /**
   * The behavior to exhibit when the message is finished being spoken.
   */
  endBehavior?:
    | 'END_BEHAVIOR_UNSPECIFIED'
    | 'END_BEHAVIOR_HANG_UP_SOFT'
    | 'END_BEHAVIOR_HANG_UP_STRICT';
};

/**
 * The requirements for using a tool, which must be satisfied when creating a call with the tool.
 */
export type UltravoxV1ToolRequirements = {
  /**
   * Security requirements for an HTTP tool.
   */
  httpSecurityOptions?: UltravoxV1SecurityOptions;
  /**
   * Dynamic parameters that must be overridden with an explicit (static) value.
   */
  requiredParameterOverrides?: Array<string>;
};

/**
 * A security requirement that will automatically be fulfilled during call creation.
 * The generated token will be set as an X-Ultravox-Call-Token header when the tool
 * is invoked. The token is only verifiable by the Ultravox service and should not be
 * used for authentication by any other service.
 * The token will also be invalid as soon as the call is completed.
 */
export type UltravoxV1UltravoxCallTokenRequirement = {
  /**
   * The scopes that must be present in the token.
   */
  scopes?: Array<string>;
};

/**
 * The specification of how to acquire documents for uploaded documents source.
 */
export type UltravoxV1UploadSpec = {
  /**
   * The IDs of uploaded documents. These documents must
   * have been previously uploaded using the document upload API.
   */
  documentIds?: Array<string>;
};

/**
 * Call-level VAD settings.
 */
export type UltravoxV1VadSettings = {
  /**
   * The minimum amount of time the agent will wait to respond after the user seems to be done
   * speaking. Increasing this value will make the agent less eager to respond, which may increase
   * perceived response latency but will also make the agent less likely to jump in before the user
   * is really done speaking.
   *
   * Built-in VAD currently operates on 32ms frames, so only multiples of 32ms are meaningful.
   * (Anything from 1ms to 31ms will produce the same result.)
   *
   * Defaults to "0.384s" (384ms) as a starting point, but there's nothing special about this value
   * aside from it corresponding to 12 VAD frames.
   */
  turnEndpointDelay?: string;
  /**
   * The minimum duration of user speech required to be considered a user turn.
   * Increasing this value will cause the agent to ignore short user audio. This may be useful in
   * particularly noisy environments, but it comes at the cost of possibly ignoring very short
   * user responses such as "yes" or "no".
   *
   * Defaults to "0s" meaning the agent considers all user audio inputs (that make it through
   * built-in noise cancellation).
   */
  minimumTurnDuration?: string;
  /**
   * The minimum duration of user speech required to interrupt the agent. This works the same way
   * as minimumTurnDuration, but allows for a higher threshold for interrupting the agent. (This
   * value will be ignored if it is less than minimumTurnDuration.)
   *
   * Defaults to "0.09s" (90ms) as a starting point, but there's nothing special about this value.
   */
  minimumInterruptionDuration?: string;
  /**
   * The threshold for the VAD to consider a frame as speech. This is a value between 0.1 and 1.
   *
   * Miniumum value is 0.1, which is the default value.
   */
  frameActivationThreshold?: number;
};

export type AccountsListData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/accounts';
};

export type AccountsListResponses = {
  200: Array<AccountReadable>;
};

export type AccountsListResponse =
  AccountsListResponses[keyof AccountsListResponses];

export type AccountsMeRetrieveData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/accounts/me';
};

export type AccountsMeRetrieveResponses = {
  200: AccountReadable;
};

export type AccountsMeRetrieveResponse =
  AccountsMeRetrieveResponses[keyof AccountsMeRetrieveResponses];

export type AccountsMeBillingRetrieveData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/accounts/me/billing';
};

export type AccountsMeBillingRetrieveResponses = {
  200: AccountBillingInfo;
};

export type AccountsMeBillingRetrieveResponse =
  AccountsMeBillingRetrieveResponses[keyof AccountsMeBillingRetrieveResponses];

export type AccountsMeBillingInvoicesRetrieveData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The pagination cursor value.
     */
    cursor?: string;
    /**
     * Number of results to return per page.
     */
    pageSize?: number;
  };
  url: '/api/accounts/me/billing/invoices';
};

export type AccountsMeBillingInvoicesRetrieveResponses = {
  200: PaginatedInvoiceListReadable;
};

export type AccountsMeBillingInvoicesRetrieveResponse =
  AccountsMeBillingInvoicesRetrieveResponses[keyof AccountsMeBillingInvoicesRetrieveResponses];

export type AccountsMeBillingUsageRetrieveData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Start date (UTC, inclusive) for per-day usage information. Defaults to the start of monthly billing cycle.
     */
    fromDate?: string;
    /**
     * End date (UTC, exclusive) for per-day usage information. Max 90 days after fromDate.
     */
    toDate?: string;
  };
  url: '/api/accounts/me/billing/usage';
};

export type AccountsMeBillingUsageRetrieveResponses = {
  200: UsageResponseReadable;
};

export type AccountsMeBillingUsageRetrieveResponse =
  AccountsMeBillingUsageRetrieveResponses[keyof AccountsMeBillingUsageRetrieveResponses];

export type AccountsMeBillingSubscriptionRetrieveData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/accounts/me/billing_subscription';
};

export type AccountsMeTtsApiKeysRetrieveData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api/accounts/me/tts_api_keys';
};

export type AccountsMeTtsApiKeysRetrieveResponses = {
  200: AccountTtsKeys;
};

export type AccountsMeTtsApiKeysRetrieveResponse =
  AccountsMeTtsApiKeysRetrieveResponses[keyof AccountsMeTtsApiKeysRetrieveResponses];

export type AccountsMeTtsApiKeysPartialUpdateData = {
  body?: PatchedSetTtsApiKeysRequest;
  path?: never;
  query?: never;
  url: '/api/accounts/me/tts_api_keys';
};

export type AccountsMeTtsApiKeysPartialUpdateResponses = {
  200: AccountTtsKeys;
};

export type AccountsMeTtsApiKeysPartialUpdateResponse =
  AccountsMeTtsApiKeysPartialUpdateResponses[keyof AccountsMeTtsApiKeysPartialUpdateResponses];

export type AccountsMeUsageCallsRetrieveData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Maximum duration of calls
     */
    durationMax?: string;
    /**
     * Minimum duration of calls
     */
    durationMin?: string;
    /**
     * Start date (inclusive) for filtering calls by creation date
     */
    fromDate?: string;
    /**
     * Filter calls by metadata. Use metadata.key=value to filter by specific key-value pairs.
     */
    metadata?: {
      [key: string]: string;
    };
    /**
     * The search string used to filter results
     */
    search?: string;
    /**
     * End date (inclusive) for filtering calls by creation date
     */
    toDate?: string;
    /**
     * Filter calls by the associated voice ID
     */
    voiceId?: string;
  };
  url: '/api/accounts/me/usage/calls';
};

export type AccountsMeUsageCallsRetrieveResponses = {
  200: CallUsage;
};

export type AccountsMeUsageCallsRetrieveResponse =
  AccountsMeUsageCallsRetrieveResponses[keyof AccountsMeUsageCallsRetrieveResponses];

export type AgentsListData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The pagination cursor value.
     */
    cursor?: string;
    /**
     * Number of results to return per page.
     */
    pageSize?: number;
  };
  url: '/api/agents';
};

export type AgentsListResponses = {
  200: PaginatedAgentListReadable;
};

export type AgentsListResponse = AgentsListResponses[keyof AgentsListResponses];

export type AgentsCreateData = {
  body?: AgentWritable;
  path?: never;
  query?: never;
  url: '/api/agents';
};

export type AgentsCreateResponses = {
  201: AgentReadable;
};

export type AgentsCreateResponse =
  AgentsCreateResponses[keyof AgentsCreateResponses];

export type AgentsDestroyData = {
  body?: never;
  path: {
    agent_id: string;
  };
  query?: never;
  url: '/api/agents/{agent_id}';
};

export type AgentsDestroyResponses = {
  /**
   * No response body
   */
  204: void;
};

export type AgentsDestroyResponse =
  AgentsDestroyResponses[keyof AgentsDestroyResponses];

export type AgentsRetrieveData = {
  body?: never;
  path: {
    agent_id: string;
  };
  query?: never;
  url: '/api/agents/{agent_id}';
};

export type AgentsRetrieveResponses = {
  200: AgentReadable;
};

export type AgentsRetrieveResponse =
  AgentsRetrieveResponses[keyof AgentsRetrieveResponses];

export type AgentsPartialUpdateData = {
  body?: PatchedAgentWritable;
  path: {
    agent_id: string;
  };
  query?: never;
  url: '/api/agents/{agent_id}';
};

export type AgentsPartialUpdateResponses = {
  200: AgentReadable;
};

export type AgentsPartialUpdateResponse =
  AgentsPartialUpdateResponses[keyof AgentsPartialUpdateResponses];

export type AgentsCallsListData = {
  body?: never;
  path: {
    agent_id: string;
  };
  query?: {
    /**
     * The pagination cursor value.
     */
    cursor?: string;
    /**
     * Number of results to return per page.
     */
    pageSize?: number;
  };
  url: '/api/agents/{agent_id}/calls';
};

export type AgentsCallsListResponses = {
  200: PaginatedCallListReadable;
};

export type AgentsCallsListResponse =
  AgentsCallsListResponses[keyof AgentsCallsListResponses];

export type AgentsCallsCreateData = {
  body?: UltravoxV1StartAgentCallRequest;
  path: {
    agent_id: string;
  };
  query?: never;
  url: '/api/agents/{agent_id}/calls';
};

export type AgentsCallsCreateResponses = {
  201: CallReadable;
};

export type AgentsCallsCreateResponse =
  AgentsCallsCreateResponses[keyof AgentsCallsCreateResponses];

export type ApiKeysListData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The pagination cursor value.
     */
    cursor?: string;
    /**
     * Number of results to return per page.
     */
    pageSize?: number;
  };
  url: '/api/api_keys';
};

export type ApiKeysListResponses = {
  200: PaginatedApiKeyListReadable;
};

export type ApiKeysListResponse =
  ApiKeysListResponses[keyof ApiKeysListResponses];

export type ApiKeysCreateData = {
  body: ApiKeyCreateWritable;
  path?: never;
  query?: never;
  url: '/api/api_keys';
};

export type ApiKeysCreateResponses = {
  201: ApiKeyCreateReadable;
};

export type ApiKeysCreateResponse =
  ApiKeysCreateResponses[keyof ApiKeysCreateResponses];

export type ApiKeysDestroyData = {
  body?: never;
  path: {
    api_key_prefix: string;
  };
  query?: never;
  url: '/api/api_keys/{api_key_prefix}';
};

export type ApiKeysDestroyResponses = {
  /**
   * No response body
   */
  204: void;
};

export type ApiKeysDestroyResponse =
  ApiKeysDestroyResponses[keyof ApiKeysDestroyResponses];

export type ApiKeysRetrieveData = {
  body?: never;
  path: {
    api_key_prefix: string;
  };
  query?: never;
  url: '/api/api_keys/{api_key_prefix}';
};

export type ApiKeysRetrieveResponses = {
  200: ApiKeyReadable;
};

export type ApiKeysRetrieveResponse =
  ApiKeysRetrieveResponses[keyof ApiKeysRetrieveResponses];

export type ApiKeysPartialUpdateData = {
  body?: PatchedApiKeyWritable;
  path: {
    api_key_prefix: string;
  };
  query?: never;
  url: '/api/api_keys/{api_key_prefix}';
};

export type ApiKeysPartialUpdateResponses = {
  200: ApiKeyReadable;
};

export type ApiKeysPartialUpdateResponse =
  ApiKeysPartialUpdateResponses[keyof ApiKeysPartialUpdateResponses];

export type ApiKeysUpdateData = {
  body?: ApiKeyWritable;
  path: {
    api_key_prefix: string;
  };
  query?: never;
  url: '/api/api_keys/{api_key_prefix}';
};

export type ApiKeysUpdateResponses = {
  200: ApiKeyReadable;
};

export type ApiKeysUpdateResponse =
  ApiKeysUpdateResponses[keyof ApiKeysUpdateResponses];

export type CallsListData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The pagination cursor value.
     */
    cursor?: string;
    /**
     * Maximum duration of calls
     */
    durationMax?: string;
    /**
     * Minimum duration of calls
     */
    durationMin?: string;
    /**
     * Start date (inclusive) for filtering calls by creation date
     */
    fromDate?: string;
    /**
     * Filter calls by metadata. Use metadata.key=value to filter by specific key-value pairs.
     */
    metadata?: {
      [key: string]: string;
    };
    /**
     * Number of results to return per page.
     */
    pageSize?: number;
    /**
     * The search string used to filter results
     */
    search?: string;
    /**
     * Which field to use when ordering the results.
     */
    sort?: string;
    /**
     * End date (inclusive) for filtering calls by creation date
     */
    toDate?: string;
    /**
     * Filter calls by the associated voice ID
     */
    voiceId?: string;
  };
  url: '/api/calls';
};

export type CallsListResponses = {
  200: PaginatedCallListReadable;
};

export type CallsListResponse = CallsListResponses[keyof CallsListResponses];

export type CallsCreateData = {
  body?: UltravoxV1StartCallRequest;
  path?: never;
  query?: {
    /**
     * Adds a prompt for a greeting if there's not an initial message that the model would naturally respond to (a user message or tool result).
     */
    enableGreetingPrompt?: boolean;
    /**
     * The UUID of a prior call. When specified, the new call will use the same properites as the prior call unless overriden in this request's body. The new call will also use the prior call's message history as its own initial_messages. (It's illegal to also set initial_messages in the body.)
     */
    priorCallId?: string;
  };
  url: '/api/calls';
};

export type CallsCreateResponses = {
  201: CallReadable;
};

export type CallsCreateResponse =
  CallsCreateResponses[keyof CallsCreateResponses];

export type CallsDestroyData = {
  body?: never;
  path: {
    call_id: string;
  };
  query?: never;
  url: '/api/calls/{call_id}';
};

export type CallsDestroyResponses = {
  /**
   * No response body
   */
  204: void;
};

export type CallsDestroyResponse =
  CallsDestroyResponses[keyof CallsDestroyResponses];

export type CallsRetrieveData = {
  body?: never;
  path: {
    call_id: string;
  };
  query?: never;
  url: '/api/calls/{call_id}';
};

export type CallsRetrieveResponses = {
  200: CallReadable;
};

export type CallsRetrieveResponse =
  CallsRetrieveResponses[keyof CallsRetrieveResponses];

export type CallsMessagesListData = {
  body?: never;
  path: {
    call_id: string;
  };
  query?: {
    /**
     * The pagination cursor value.
     */
    cursor?: string;
    /**
     * Number of results to return per page.
     */
    pageSize?: number;
  };
  url: '/api/calls/{call_id}/messages';
};

export type CallsMessagesListResponses = {
  200: PaginatedultravoxV1MessageList;
};

export type CallsMessagesListResponse =
  CallsMessagesListResponses[keyof CallsMessagesListResponses];

export type CallsRecordingRetrieveData = {
  body?: never;
  path: {
    call_id: string;
  };
  query?: never;
  url: '/api/calls/{call_id}/recording';
};

export type CallsRecordingRetrieveResponses = {
  200: Blob | File;
};

export type CallsRecordingRetrieveResponse =
  CallsRecordingRetrieveResponses[keyof CallsRecordingRetrieveResponses];

export type CallsStagesListData = {
  body?: never;
  path: {
    call_id: string;
  };
  query?: {
    /**
     * The pagination cursor value.
     */
    cursor?: string;
    /**
     * Number of results to return per page.
     */
    pageSize?: number;
  };
  url: '/api/calls/{call_id}/stages';
};

export type CallsStagesListResponses = {
  200: PaginatedCallStageListReadable;
};

export type CallsStagesListResponse =
  CallsStagesListResponses[keyof CallsStagesListResponses];

export type CallsStagesRetrieveData = {
  body?: never;
  path: {
    call_id: string;
    call_stage_id: string;
  };
  query?: never;
  url: '/api/calls/{call_id}/stages/{call_stage_id}';
};

export type CallsStagesRetrieveResponses = {
  200: CallStageReadable;
};

export type CallsStagesRetrieveResponse =
  CallsStagesRetrieveResponses[keyof CallsStagesRetrieveResponses];

export type CallsStagesMessagesListData = {
  body?: never;
  path: {
    call_id: string;
    call_stage_id: string;
  };
  query?: {
    /**
     * The pagination cursor value.
     */
    cursor?: string;
    /**
     * Number of results to return per page.
     */
    pageSize?: number;
  };
  url: '/api/calls/{call_id}/stages/{call_stage_id}/messages';
};

export type CallsStagesMessagesListResponses = {
  200: PaginatedultravoxV1MessageList;
};

export type CallsStagesMessagesListResponse =
  CallsStagesMessagesListResponses[keyof CallsStagesMessagesListResponses];

export type CallsStagesMessagesAudioRetrieveData = {
  body?: never;
  path: {
    call_id: string;
    call_stage_id: string;
    call_stage_message_index: number;
  };
  query?: never;
  url: '/api/calls/{call_id}/stages/{call_stage_id}/messages/{call_stage_message_index}/audio';
};

export type CallsStagesMessagesAudioRetrieveResponses = {
  /**
   * No response body
   */
  200: unknown;
};

export type CallsStagesToolsListData = {
  body?: never;
  path: {
    call_id: string;
    call_stage_id: string;
  };
  query?: never;
  url: '/api/calls/{call_id}/stages/{call_stage_id}/tools';
};

export type CallsStagesToolsListResponses = {
  200: Array<CallToolReadable>;
};

export type CallsStagesToolsListResponse =
  CallsStagesToolsListResponses[keyof CallsStagesToolsListResponses];

export type CallsToolsListData = {
  body?: never;
  path: {
    call_id: string;
  };
  query?: never;
  url: '/api/calls/{call_id}/tools';
};

export type CallsToolsListResponses = {
  200: Array<CallToolReadable>;
};

export type CallsToolsListResponse =
  CallsToolsListResponses[keyof CallsToolsListResponses];

export type CorporaListData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The pagination cursor value.
     */
    cursor?: string;
    /**
     * Number of results to return per page.
     */
    pageSize?: number;
  };
  url: '/api/corpora';
};

export type CorporaListResponses = {
  200: PaginatedultravoxV1CorpusList;
};

export type CorporaListResponse =
  CorporaListResponses[keyof CorporaListResponses];

export type CorporaCreateData = {
  body: UltravoxV1Corpus;
  path?: never;
  query?: never;
  url: '/api/corpora';
};

export type CorporaCreateResponses = {
  201: UltravoxV1Corpus;
};

export type CorporaCreateResponse =
  CorporaCreateResponses[keyof CorporaCreateResponses];

export type CorporaDestroyData = {
  body?: never;
  path: {
    corpus_id: string;
  };
  query?: never;
  url: '/api/corpora/{corpus_id}';
};

export type CorporaDestroyResponses = {
  /**
   * No response body
   */
  204: void;
};

export type CorporaDestroyResponse =
  CorporaDestroyResponses[keyof CorporaDestroyResponses];

export type CorporaRetrieveData = {
  body?: never;
  path: {
    corpus_id: string;
  };
  query?: never;
  url: '/api/corpora/{corpus_id}';
};

export type CorporaRetrieveResponses = {
  200: UltravoxV1Corpus;
};

export type CorporaRetrieveResponse =
  CorporaRetrieveResponses[keyof CorporaRetrieveResponses];

export type CorporaPartialUpdateData = {
  body?: UltravoxV1Corpus;
  path: {
    corpus_id: string;
  };
  query?: never;
  url: '/api/corpora/{corpus_id}';
};

export type CorporaPartialUpdateResponses = {
  200: UltravoxV1Corpus;
};

export type CorporaPartialUpdateResponse =
  CorporaPartialUpdateResponses[keyof CorporaPartialUpdateResponses];

export type CorporaUpdateData = {
  body: UltravoxV1Corpus;
  path: {
    corpus_id: string;
  };
  query?: never;
  url: '/api/corpora/{corpus_id}';
};

export type CorporaUpdateResponses = {
  200: UltravoxV1Corpus;
};

export type CorporaUpdateResponse =
  CorporaUpdateResponses[keyof CorporaUpdateResponses];

export type CorporaQueryData = {
  body?: UltravoxV1QueryCorpusRequest;
  path: {
    corpus_id: string;
  };
  query?: never;
  url: '/api/corpora/{corpus_id}/query';
};

export type CorporaQueryResponses = {
  200: Array<UltravoxV1CorpusQueryResult>;
};

export type CorporaQueryResponse =
  CorporaQueryResponses[keyof CorporaQueryResponses];

export type CorporaSourcesListData = {
  body?: never;
  path: {
    corpus_id: string;
  };
  query?: {
    /**
     * The pagination cursor value.
     */
    cursor?: string;
    /**
     * Number of results to return per page.
     */
    pageSize?: number;
  };
  url: '/api/corpora/{corpus_id}/sources';
};

export type CorporaSourcesListResponses = {
  200: PaginatedultravoxV1CorpusSourceList;
};

export type CorporaSourcesListResponse =
  CorporaSourcesListResponses[keyof CorporaSourcesListResponses];

export type CorporaSourcesCreateData = {
  body: UltravoxV1CorpusSource;
  path: {
    corpus_id: string;
  };
  query?: never;
  url: '/api/corpora/{corpus_id}/sources';
};

export type CorporaSourcesCreateResponses = {
  201: UltravoxV1CorpusSource;
};

export type CorporaSourcesCreateResponse =
  CorporaSourcesCreateResponses[keyof CorporaSourcesCreateResponses];

export type CorporaSourcesDestroyData = {
  body?: never;
  path: {
    corpus_id: string;
    source_id: string;
  };
  query?: never;
  url: '/api/corpora/{corpus_id}/sources/{source_id}';
};

export type CorporaSourcesDestroyResponses = {
  /**
   * No response body
   */
  204: void;
};

export type CorporaSourcesDestroyResponse =
  CorporaSourcesDestroyResponses[keyof CorporaSourcesDestroyResponses];

export type CorporaSourcesRetrieveData = {
  body?: never;
  path: {
    corpus_id: string;
    source_id: string;
  };
  query?: never;
  url: '/api/corpora/{corpus_id}/sources/{source_id}';
};

export type CorporaSourcesRetrieveResponses = {
  200: UltravoxV1CorpusSource;
};

export type CorporaSourcesRetrieveResponse =
  CorporaSourcesRetrieveResponses[keyof CorporaSourcesRetrieveResponses];

export type CorporaSourcesPartialUpdateData = {
  body?: UltravoxV1CorpusSource;
  path: {
    corpus_id: string;
    source_id: string;
  };
  query?: never;
  url: '/api/corpora/{corpus_id}/sources/{source_id}';
};

export type CorporaSourcesPartialUpdateResponses = {
  200: UltravoxV1CorpusSource;
};

export type CorporaSourcesPartialUpdateResponse =
  CorporaSourcesPartialUpdateResponses[keyof CorporaSourcesPartialUpdateResponses];

export type CorporaSourcesUpdateData = {
  body: UltravoxV1CorpusSource;
  path: {
    corpus_id: string;
    source_id: string;
  };
  query?: never;
  url: '/api/corpora/{corpus_id}/sources/{source_id}';
};

export type CorporaSourcesUpdateResponses = {
  200: UltravoxV1CorpusSource;
};

export type CorporaSourcesUpdateResponse =
  CorporaSourcesUpdateResponses[keyof CorporaSourcesUpdateResponses];

export type CorporaSourcesDocumentsListData = {
  body?: never;
  path: {
    corpus_id: string;
    source_id: string;
  };
  query?: {
    /**
     * The pagination cursor value.
     */
    cursor?: string;
    /**
     * Number of results to return per page.
     */
    pageSize?: number;
  };
  url: '/api/corpora/{corpus_id}/sources/{source_id}/documents';
};

export type CorporaSourcesDocumentsListResponses = {
  200: PaginatedultravoxV1CorpusDocumentList;
};

export type CorporaSourcesDocumentsListResponse =
  CorporaSourcesDocumentsListResponses[keyof CorporaSourcesDocumentsListResponses];

export type CorporaSourcesDocumentsRetrieveData = {
  body?: never;
  path: {
    corpus_id: string;
    document_id: string;
    source_id: string;
  };
  query?: never;
  url: '/api/corpora/{corpus_id}/sources/{source_id}/documents/{document_id}';
};

export type CorporaSourcesDocumentsRetrieveResponses = {
  200: UltravoxV1CorpusDocument;
};

export type CorporaSourcesDocumentsRetrieveResponse =
  CorporaSourcesDocumentsRetrieveResponses[keyof CorporaSourcesDocumentsRetrieveResponses];

export type CorporaUploadsCreateData = {
  body: CorpusUploadsRequest;
  path: {
    corpus_id: string;
  };
  query?: never;
  url: '/api/corpora/{corpus_id}/uploads';
};

export type CorporaUploadsCreateResponses = {
  201: CorpusUploadsResponse;
};

export type CorporaUploadsCreateResponse =
  CorporaUploadsCreateResponses[keyof CorporaUploadsCreateResponses];

export type DeletedCallsListData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The pagination cursor value.
     */
    cursor?: string;
    /**
     * Maximum duration of calls
     */
    durationMax?: string;
    /**
     * Minimum duration of calls
     */
    durationMin?: string;
    /**
     * Start date (inclusive) for filtering calls by creation date
     */
    fromDate?: string;
    /**
     * Filter calls by metadata. Use metadata.key=value to filter by specific key-value pairs.
     */
    metadata?: {
      [key: string]: string;
    };
    /**
     * Number of results to return per page.
     */
    pageSize?: number;
    /**
     * The search string used to filter results
     */
    search?: string;
    /**
     * End date (inclusive) for filtering calls by creation date
     */
    toDate?: string;
    /**
     * Filter calls by the associated voice ID
     */
    voiceId?: string;
  };
  url: '/api/deleted_calls';
};

export type DeletedCallsListResponses = {
  200: PaginatedCallTombstoneListReadable;
};

export type DeletedCallsListResponse =
  DeletedCallsListResponses[keyof DeletedCallsListResponses];

export type DeletedCallsRetrieveData = {
  body?: never;
  path: {
    call_id: string;
  };
  query?: never;
  url: '/api/deleted_calls/{call_id}';
};

export type DeletedCallsRetrieveResponses = {
  200: CallTombstoneReadable;
};

export type DeletedCallsRetrieveResponse =
  DeletedCallsRetrieveResponses[keyof DeletedCallsRetrieveResponses];

export type ModelsListData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The pagination cursor value.
     */
    cursor?: string;
    /**
     * Number of results to return per page.
     */
    pageSize?: number;
  };
  url: '/api/models';
};

export type ModelsListResponses = {
  200: PaginatedModelAliasListReadable;
};

export type ModelsListResponse = ModelsListResponses[keyof ModelsListResponses];

export type SchemaRetrieveData = {
  body?: never;
  path?: never;
  query?: {
    format?: 'json' | 'yaml';
    lang?:
      | 'af'
      | 'ar'
      | 'ar-dz'
      | 'ast'
      | 'az'
      | 'be'
      | 'bg'
      | 'bn'
      | 'br'
      | 'bs'
      | 'ca'
      | 'ckb'
      | 'cs'
      | 'cy'
      | 'da'
      | 'de'
      | 'dsb'
      | 'el'
      | 'en'
      | 'en-au'
      | 'en-gb'
      | 'eo'
      | 'es'
      | 'es-ar'
      | 'es-co'
      | 'es-mx'
      | 'es-ni'
      | 'es-ve'
      | 'et'
      | 'eu'
      | 'fa'
      | 'fi'
      | 'fr'
      | 'fy'
      | 'ga'
      | 'gd'
      | 'gl'
      | 'he'
      | 'hi'
      | 'hr'
      | 'hsb'
      | 'hu'
      | 'hy'
      | 'ia'
      | 'id'
      | 'ig'
      | 'io'
      | 'is'
      | 'it'
      | 'ja'
      | 'ka'
      | 'kab'
      | 'kk'
      | 'km'
      | 'kn'
      | 'ko'
      | 'ky'
      | 'lb'
      | 'lt'
      | 'lv'
      | 'mk'
      | 'ml'
      | 'mn'
      | 'mr'
      | 'ms'
      | 'my'
      | 'nb'
      | 'ne'
      | 'nl'
      | 'nn'
      | 'os'
      | 'pa'
      | 'pl'
      | 'pt'
      | 'pt-br'
      | 'ro'
      | 'ru'
      | 'sk'
      | 'sl'
      | 'sq'
      | 'sr'
      | 'sr-latn'
      | 'sv'
      | 'sw'
      | 'ta'
      | 'te'
      | 'tg'
      | 'th'
      | 'tk'
      | 'tr'
      | 'tt'
      | 'udm'
      | 'ug'
      | 'uk'
      | 'ur'
      | 'uz'
      | 'vi'
      | 'zh-hans'
      | 'zh-hant';
  };
  url: '/api/schema/';
};

export type SchemaRetrieveResponses = {
  200: {
    [key: string]: unknown;
  };
};

export type SchemaRetrieveResponse =
  SchemaRetrieveResponses[keyof SchemaRetrieveResponses];

export type ToolsListData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The pagination cursor value.
     */
    cursor?: string;
    /**
     * The ownership used to filter results
     */
    ownership?: string;
    /**
     * Number of results to return per page.
     */
    pageSize?: number;
    /**
     * The search string used to filter results
     */
    search?: string;
  };
  url: '/api/tools';
};

export type ToolsListResponses = {
  200: PaginatedToolListReadable;
};

export type ToolsListResponse = ToolsListResponses[keyof ToolsListResponses];

export type ToolsCreateData = {
  body?: ToolWritable;
  path?: never;
  query?: never;
  url: '/api/tools';
};

export type ToolsCreateResponses = {
  201: ToolReadable;
};

export type ToolsCreateResponse =
  ToolsCreateResponses[keyof ToolsCreateResponses];

export type ToolsDestroyData = {
  body?: never;
  path: {
    tool_id: string;
  };
  query?: never;
  url: '/api/tools/{tool_id}';
};

export type ToolsDestroyResponses = {
  /**
   * No response body
   */
  204: void;
};

export type ToolsDestroyResponse =
  ToolsDestroyResponses[keyof ToolsDestroyResponses];

export type ToolsRetrieveData = {
  body?: never;
  path: {
    tool_id: string;
  };
  query?: never;
  url: '/api/tools/{tool_id}';
};

export type ToolsRetrieveResponses = {
  200: ToolReadable;
};

export type ToolsRetrieveResponse =
  ToolsRetrieveResponses[keyof ToolsRetrieveResponses];

export type ToolsUpdateData = {
  body: ToolWritable;
  path: {
    tool_id: string;
  };
  query?: never;
  url: '/api/tools/{tool_id}';
};

export type ToolsUpdateResponses = {
  200: ToolReadable;
};

export type ToolsUpdateResponse =
  ToolsUpdateResponses[keyof ToolsUpdateResponses];

export type ToolsHistoryListData = {
  body?: never;
  path: {
    tool_id: string;
  };
  query?: {
    /**
     * The pagination cursor value.
     */
    cursor?: string;
    /**
     * Number of results to return per page.
     */
    pageSize?: number;
  };
  url: '/api/tools/{tool_id}/history';
};

export type ToolsHistoryListResponses = {
  200: PaginatedToolHistoryListReadable;
};

export type ToolsHistoryListResponse =
  ToolsHistoryListResponses[keyof ToolsHistoryListResponses];

export type ToolsTestCreateData = {
  body?: never;
  path: {
    tool_id: string;
  };
  query?: never;
  url: '/api/tools/{tool_id}/test';
};

export type ToolsTestCreateResponses = {
  default: unknown;
};

export type VoicesListData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The pagination cursor value.
     */
    cursor?: string;
    /**
     * The ownership used filter results
     */
    ownership?: string;
    /**
     * Number of results to return per page.
     */
    pageSize?: number;
    /**
     * The search string used to filter results
     */
    search?: string;
  };
  url: '/api/voices';
};

export type VoicesListResponses = {
  200: PaginatedVoiceListReadable;
};

export type VoicesListResponse = VoicesListResponses[keyof VoicesListResponses];

export type VoicesCreateData = {
  body?: {
    /**
     * An audio file containing a sample of the voice to clone.
     */
    file: Blob | File;
    /**
     * Name for the cloned voice. Must be unique within your account.
     */
    name: string;
    /**
     * Optional description for the voice. If not provided, a default description will be generated.
     */
    description?: string;
  };
  path?: never;
  query?: never;
  url: '/api/voices';
};

export type VoicesCreateResponses = {
  200: Voice;
};

export type VoicesCreateResponse =
  VoicesCreateResponses[keyof VoicesCreateResponses];

export type VoicesDestroyData = {
  body?: never;
  path: {
    voice_id: string;
  };
  query?: never;
  url: '/api/voices/{voice_id}';
};

export type VoicesDestroyResponses = {
  /**
   * No response body
   */
  204: void;
};

export type VoicesDestroyResponse =
  VoicesDestroyResponses[keyof VoicesDestroyResponses];

export type VoicesRetrieveData = {
  body?: never;
  path: {
    voice_id: string;
  };
  query?: never;
  url: '/api/voices/{voice_id}';
};

export type VoicesRetrieveResponses = {
  200: Voice;
};

export type VoicesRetrieveResponse =
  VoicesRetrieveResponses[keyof VoicesRetrieveResponses];

export type WebhooksListData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The pagination cursor value.
     */
    cursor?: string;
    /**
     * Number of results to return per page.
     */
    pageSize?: number;
  };
  url: '/api/webhooks';
};

export type WebhooksListResponses = {
  200: PaginatedWebhookListReadable;
};

export type WebhooksListResponse =
  WebhooksListResponses[keyof WebhooksListResponses];

export type WebhooksCreateData = {
  body: WebhookWritable;
  path?: never;
  query?: never;
  url: '/api/webhooks';
};

export type WebhooksCreateResponses = {
  201: WebhookReadable;
};

export type WebhooksCreateResponse =
  WebhooksCreateResponses[keyof WebhooksCreateResponses];

export type WebhooksDestroyData = {
  body?: never;
  path: {
    webhook_id: string;
  };
  query?: never;
  url: '/api/webhooks/{webhook_id}';
};

export type WebhooksDestroyResponses = {
  /**
   * No response body
   */
  204: void;
};

export type WebhooksDestroyResponse =
  WebhooksDestroyResponses[keyof WebhooksDestroyResponses];

export type WebhooksRetrieveData = {
  body?: never;
  path: {
    webhook_id: string;
  };
  query?: never;
  url: '/api/webhooks/{webhook_id}';
};

export type WebhooksRetrieveResponses = {
  200: WebhookReadable;
};

export type WebhooksRetrieveResponse =
  WebhooksRetrieveResponses[keyof WebhooksRetrieveResponses];

export type WebhooksPartialUpdateData = {
  body?: PatchedWebhookWritable;
  path: {
    webhook_id: string;
  };
  query?: never;
  url: '/api/webhooks/{webhook_id}';
};

export type WebhooksPartialUpdateResponses = {
  200: WebhookReadable;
};

export type WebhooksPartialUpdateResponse =
  WebhooksPartialUpdateResponses[keyof WebhooksPartialUpdateResponses];

export type WebhooksUpdateData = {
  body: WebhookWritable;
  path: {
    webhook_id: string;
  };
  query?: never;
  url: '/api/webhooks/{webhook_id}';
};

export type WebhooksUpdateResponses = {
  200: WebhookReadable;
};

export type WebhooksUpdateResponse =
  WebhooksUpdateResponses[keyof WebhooksUpdateResponses];

export type ClientOptions = {
  baseURL: 'https://api.ultravox.ai' | (string & {});
};
